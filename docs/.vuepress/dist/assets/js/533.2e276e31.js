(window.webpackJsonp=window.webpackJsonp||[]).push([[533],{903:function(e,v,_){"use strict";_.r(v);var c=_(28),t=Object(c.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"react-应用的宏观包结构-web-开发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-应用的宏观包结构-web-开发"}},[e._v("#")]),e._v(" React 应用的宏观包结构(web 开发)")]),e._v(" "),_("blockquote",[_("p",[e._v("React 工程目录的packages下包含35个包。")]),e._v(" "),_("p",[e._v("其中与"),_("code",[e._v("web")]),e._v("开发相关的核心包共有4个，本篇以这四个包为线索展开，深入react内部原理。")])]),e._v(" "),_("h2",{attrs:{id:"基础包结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础包结构"}},[e._v("#")]),e._v(" 基础包结构")]),e._v(" "),_("h3",{attrs:{id:"react"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[e._v("#")]),e._v(" react")]),e._v(" "),_("p",[e._v("react基础包，只提供定义react组件("),_("code",[e._v("createElement")]),e._v(")的必要函数，一般来说需要和渲染器("),_("code",[e._v("react-dom")]),e._v("、"),_("code",[e._v("react-native")]),e._v(")一同使用，在编写react应用的代码时，大部分都是调用此包的api。")]),e._v(" "),_("h3",{attrs:{id:"react-dom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-dom"}},[e._v("#")]),e._v(" react-dom")]),e._v(" "),_("p",[e._v("react渲染器之一，是react与web平台连接的桥梁(可以在浏览器和nodejs环境中使用)，将"),_("code",[e._v("react-reconciler")]),e._v("中的运行结果输出到web界面上，在编写"),_("code",[e._v("react")]),e._v("应用的代码时，大多数场景下，能用到此包的就是一个入口函数"),_("code",[e._v("ReactDOM.render(<App/>, document.getElementById('root'))")]),e._v("，其余使用的API，基本上是"),_("code",[e._v("react")]),e._v("包提供的。")]),e._v(" "),_("h3",{attrs:{id:"react-reconciler"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-reconciler"}},[e._v("#")]),e._v(" react-reconciler")]),e._v(" "),_("p",[e._v("react得以运行的核心包(综合协调"),_("code",[e._v("react-dom")]),e._v("，"),_("code",[e._v("react")]),e._v("，"),_("code",[e._v("scheduler")]),e._v("各包之间的调用与配合)。")]),e._v(" "),_("p",[e._v("管理react应用状态的输入和结果的输出，将输入信号最终转换为输出信号传递给渲染器。")]),e._v(" "),_("ul",[_("li",[e._v("接受输入("),_("code",[e._v("scheduleUpdateOnFiber")]),e._v(")，将"),_("code",[e._v("fiber")]),e._v("树生成逻辑封装到一个回调函数中(涉及"),_("code",[e._v("fiber")]),e._v("树形结构)，"),_("code",[e._v("fiber.updateQueue")]),e._v("队列，调和算法等）")]),e._v(" "),_("li",[e._v("把此回调函数("),_("code",[e._v("performSyncWorkRoot")]),e._v("或"),_("code",[e._v("performConcurrentWorkOnRoot")]),e._v(")送入"),_("code",[e._v("scheduler")]),e._v("进行调度")]),e._v(" "),_("li",[_("code",[e._v("scheduler")]),e._v("会控制回调函数执行的时机，回调函数执行完成后得到全新的fiber树")]),e._v(" "),_("li",[e._v("再调用渲染器(如"),_("code",[e._v("react-dom")]),e._v("，"),_("code",[e._v("react-native")]),e._v("等)将fiber树形结构最终反应到界面上")])]),e._v(" "),_("h3",{attrs:{id:"scheduler"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#scheduler"}},[e._v("#")]),e._v(" scheduler")]),e._v(" "),_("p",[e._v("调度机制的核心实现，控制由"),_("code",[e._v("react-reconciler")]),e._v("送入的回调函数的执行时机，在"),_("code",[e._v("concurrent")]),e._v("模式下可以实现任务分片，在编写"),_("code",[e._v("react")]),e._v("应用的代码时，同样几乎不会直接用到此包提供的api。")]),e._v(" "),_("ul",[_("li",[e._v("核心任务就是执行回调(回调函数由"),_("code",[e._v("react-reconciler")]),e._v("提供)")]),e._v(" "),_("li",[e._v("通过控制回调函数的执行时机，来达到任务分片的目的，实现可中断渲染("),_("code",[e._v("concurrent")]),e._v("模式下才有此特性)")])]),e._v(" "),_("h2",{attrs:{id:"宏观总览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏观总览"}},[e._v("#")]),e._v(" 宏观总览")]),e._v(" "),_("h3",{attrs:{id:"架构分层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#架构分层"}},[e._v("#")]),e._v(" 架构分层")]),e._v(" "),_("p",[e._v("为了便于理解，可将react应用整体结构分为接口层("),_("code",[e._v("api")]),e._v(")和内核层("),_("code",[e._v("core")]),e._v(")2个部分。")]),e._v(" "),_("h4",{attrs:{id:"接口层-api"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口层-api"}},[e._v("#")]),e._v(" 接口层(api)")]),e._v(" "),_("p",[_("code",[e._v("react")]),e._v("包，平时在开发过程中使用的绝大部分"),_("code",[e._v("api")]),e._v("均来自此包，在"),_("code",[e._v("react")]),e._v("启动之后，正常可以改变渲染的基本操作有3个。")]),e._v(" "),_("ul",[_("li",[e._v("class 组件中使用"),_("code",[e._v("setState()")])]),e._v(" "),_("li",[e._v("function 组件里面使用hook，并发起"),_("code",[e._v("dispatchAction")]),e._v("去改变hook对象")]),e._v(" "),_("li",[e._v("改变 context(其实也需要"),_("code",[e._v("setState")]),e._v("或"),_("code",[e._v("dispatchAction")]),e._v("的辅助才能改变)")])]),e._v(" "),_("p",[e._v("以上"),_("code",[e._v("setState")]),e._v("和"),_("code",[e._v("dispatchAction")]),e._v("都由"),_("code",[e._v("react")]),e._v("包直接暴露，所以想要react工作，基本上都是调用"),_("code",[e._v("react")]),e._v("包的api与其他包进行交互。")]),e._v(" "),_("h4",{attrs:{id:"内核层-core"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核层-core"}},[e._v("#")]),e._v(" 内核层(core)")]),e._v(" "),_("p",[e._v("整个内核部分，由3部分构成：")]),e._v(" "),_("ul",[_("li",[e._v("调度器："),_("code",[e._v("scheduler")]),e._v("包，核心职责只有1个，就是执行回调。\n"),_("ul",[_("li",[e._v("把"),_("code",[e._v("react-reconciler")]),e._v("提供的回调函数，包装到一个任务对象中。")]),e._v(" "),_("li",[e._v("在内部维护一个任务队列，优先级高的排在最前面。")]),e._v(" "),_("li",[e._v("循环消费任务队列，直到队列清空。")])])]),e._v(" "),_("li",[e._v("构造器："),_("code",[e._v("react-reconciler")]),e._v("包，有3个核心职责。\n"),_("ul",[_("li",[e._v("装载渲染器，渲染器必须实现"),_("code",[e._v("HostConfig")]),e._v("协议(如:"),_("code",[e._v("react-dom")]),e._v(")，保证在需要的时候，能够正确调用渲染器的api，生成实际节点(如:"),_("code",[e._v("dom")]),e._v("节点)。")]),e._v(" "),_("li",[e._v("接受"),_("code",[e._v("react-dom")]),e._v("包(初次"),_("code",[e._v("render")]),e._v(")和"),_("code",[e._v("react")]),e._v("包(后续更新"),_("code",[e._v("state")]),e._v(")发起的更新请求。")]),e._v(" "),_("li",[e._v("将"),_("code",[e._v("fiber")]),e._v("树的构造过程包装在一个回调函数中，并将此回调函数传入到"),_("code",[e._v("scheduler")]),e._v("包等待调度。")])])]),e._v(" "),_("li",[e._v("渲染器："),_("code",[e._v("react-dom")]),e._v("包，有2个核心职责。\n"),_("ul",[_("li",[e._v("引导"),_("code",[e._v("react")]),e._v("应用的启动。(通过"),_("code",[e._v("ReactDOM.render")]),e._v(")")]),e._v(" "),_("li",[e._v("实现"),_("code",[e._v("HostConfig")]),e._v("协议(源码在ReactDOMHostConfig.js中)，能够将"),_("code",[e._v("react-reconciler")]),e._v("包构造出来的"),_("code",[e._v("fiber")]),e._v("树表现出来，生成dom节点(浏览器中)，生成字符串(ssr)")])])])]),e._v(" "),_("h3",{attrs:{id:"内核关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核关系"}},[e._v("#")]),e._v(" 内核关系")]),e._v(" "),_("p",[e._v("现将内核3个包的主要职责和调用关系，绘制到一张概览图上：")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/core-packages.c2850581.png",alt:""}})]),e._v(" "),_("p",[e._v("注意：")]),e._v(" "),_("ul",[_("li",[e._v("红色方块代表入口函数，绿色方块代表出口函数。")]),e._v(" "),_("li",[e._v("package之间的调用脉络就是通过板块间的入口和出口函数连接起来的。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);