(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{430:function(v,_,t){"use strict";t.r(_);var a=t(27),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[v._v("#")]),v._v(" 单例模式")]),v._v(" "),t("p",[t("code",[v._v("单例模式")]),v._v("(Singleton Pattern)，又称单件模式或单态模式。")]),v._v(" "),t("p",[v._v("单例模式属于"),t("code",[v._v("对象创建型模式")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"模式动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式动机"}},[v._v("#")]),v._v(" 模式动机")]),v._v(" "),t("p",[v._v("对于系统中的某些类来说，只有一个实例很重要。")]),v._v(" "),t("p",[v._v("例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。")]),v._v(" "),t("p",[v._v("如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。")]),v._v(" "),t("p",[v._v("一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。")]),v._v(" "),t("h2",{attrs:{id:"模式定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式定义"}},[v._v("#")]),v._v(" 模式定义")]),v._v(" "),t("p",[v._v("单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。")]),v._v(" "),t("p",[v._v("单例模式的要点有三个：")]),v._v(" "),t("ul",[t("li",[v._v("一是某个类只能有一个实例；")]),v._v(" "),t("li",[v._v("二是它必须自行创建这个实例；")]),v._v(" "),t("li",[v._v("三是它必须自行向整个系统提供这个实例。")])]),v._v(" "),t("h2",{attrs:{id:"模式结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[v._v("#")]),v._v(" 模式结构")]),v._v(" "),t("p",[v._v("单例模式包含如下角色：")]),v._v(" "),t("ul",[t("li",[v._v("Singleton: 单例")])]),v._v(" "),t("h2",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[v._v("#")]),v._v(" 代码实现")]),v._v(" "),t("ul",[t("li",[t("RouterLink",{attrs:{to:"/knowledge/design/创建型模式/单例模式/PHP实现.html"}},[v._v("PHP实现")])],1),v._v(" "),t("li",[t("RouterLink",{attrs:{to:"/knowledge/design/创建型模式/单例模式/JS实现.html"}},[v._v("JS实现")])],1)]),v._v(" "),t("h2",{attrs:{id:"模式分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式分析"}},[v._v("#")]),v._v(" 模式分析")]),v._v(" "),t("p",[v._v("单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。")]),v._v(" "),t("p",[v._v("单例模式包含的角色只有一个，就是单例类——Singleton。")]),v._v(" "),t("p",[v._v("单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。")]),v._v(" "),t("p",[v._v("除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。")]),v._v(" "),t("p",[v._v("在单例模式的实现过程中，需要注意如下三点：")]),v._v(" "),t("ul",[t("li",[v._v("单例类的构造函数为私有")]),v._v(" "),t("li",[v._v("提供一个自身的静态私有成员变量")]),v._v(" "),t("li",[v._v("提供一个公有的静态工厂方法")])]),v._v(" "),t("h2",{attrs:{id:"实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[v._v("#")]),v._v(" 实例")]),v._v(" "),t("p",[v._v("在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。")]),v._v(" "),t("h2",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),t("p",[v._v("单例模式的优点：")]),v._v(" "),t("ul",[t("li",[v._v("提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。")]),v._v(" "),t("li",[v._v("由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。")]),v._v(" "),t("li",[v._v("允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。")])]),v._v(" "),t("h2",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),t("p",[v._v("单例模式的缺点：")]),v._v(" "),t("ul",[t("li",[v._v("由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。")]),v._v(" "),t("li",[v._v("单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。")]),v._v(" "),t("li",[v._v("滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。")])]),v._v(" "),t("h2",{attrs:{id:"适用环境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[v._v("#")]),v._v(" 适用环境")]),v._v(" "),t("p",[v._v("在以下情况下可以使用单例模式：")]),v._v(" "),t("ul",[t("li",[v._v("系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。")]),v._v(" "),t("li",[v._v("客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。")]),v._v(" "),t("li",[v._v("在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式")])]),v._v(" "),t("h2",{attrs:{id:"模式应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式应用"}},[v._v("#")]),v._v(" 模式应用")]),v._v(" "),t("p",[v._v("一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。")])])}),[],!1,null,null,null);_.default=r.exports}}]);