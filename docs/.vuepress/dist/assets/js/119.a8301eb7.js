(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{478:function(t,v,_){"use strict";_.r(v);var a=_(27),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"迭代器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[t._v("#")]),t._v(" 迭代器模式")]),t._v(" "),_("p",[_("code",[t._v("迭代器模式")]),t._v("(Iterator Pattern)属于对象行为型模式。")]),t._v(" "),_("h2",{attrs:{id:"模式动机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式动机"}},[t._v("#")]),t._v(" 模式动机")]),t._v(" "),_("p",[t._v("一个聚合对象，如一个列表(List)或者一个集合(Set)，应该提供一种方法来让别人可以访问它的元素，而又不需要暴露它的内部结构。")]),t._v(" "),_("p",[t._v("针对不同的需要，可能还要以不同的方式遍历整个聚合对象，但是我们并不希望在聚合对象的抽象层接口中充斥着各种不同遍历的操作。")]),t._v(" "),_("p",[t._v("怎样遍历一个聚合对象，又不需要了解聚合对象的内部结构，还能够提供多种不同的遍历方式，这就是迭代器模式所要解决的问题。")]),t._v(" "),_("p",[t._v("在迭代器模式中，提供一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。")]),t._v(" "),_("p",[t._v("有了迭代器模式，我们会发现对一个很复杂的聚合对象的操作会变得如此简单。")]),t._v(" "),_("h2",{attrs:{id:"模式定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式定义"}},[t._v("#")]),t._v(" 模式定义")]),t._v(" "),_("p",[t._v("迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。其别名为游标(Cursor)。")]),t._v(" "),_("h2",{attrs:{id:"模式结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[t._v("#")]),t._v(" 模式结构")]),t._v(" "),_("p",[t._v("迭代器模式包含如下角色：")]),t._v(" "),_("ul",[_("li",[t._v("Iterator：抽象迭代器")]),t._v(" "),_("li",[t._v("ConcreteIterator：具体迭代器")]),t._v(" "),_("li",[t._v("Aggregate：抽象聚合类")]),t._v(" "),_("li",[t._v("ConcreteAggregate：具体聚合类")])]),t._v(" "),_("h2",{attrs:{id:"模式分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式分析"}},[t._v("#")]),t._v(" 模式分析")]),t._v(" "),_("p",[t._v("聚合是一个管理和组织数据对象的数据结构。")]),t._v(" "),_("p",[t._v("聚合对象主要拥有两个职责：一是存储内部数据；二是遍历内部数据。")]),t._v(" "),_("p",[t._v("存储数据是聚合对象最基本的职责。")]),t._v(" "),_("p",[t._v('将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。迭代器模式是"单一职责原则"的完美体现。')]),t._v(" "),_("p",[t._v("在迭代器模式中应用了工厂方法模式，聚合类充当工厂类，而迭代器充当产品类，由于定义了抽象层，系统的扩展性很好，在客户端可以针对抽象聚合类和抽象迭代器进行编程。")]),t._v(" "),_("p",[t._v("由于很多编程语言的类库都已经实现了迭代器模式，因此在实际使用中我们很少自定义迭代器，只需要直接使用Java、C#等语言中已定义的迭代器即可，迭代器已经成为我们操作聚合对象的基本工具之一。")]),t._v(" "),_("h2",{attrs:{id:"代码实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[t._v("#")]),t._v(" 代码实现")]),t._v(" "),_("ul",[_("li",[_("p",[_("RouterLink",{attrs:{to:"/knowledge/design/行为型模式/迭代器模式/JS实现.html"}},[t._v("JS实现")])],1)]),t._v(" "),_("li",[_("p",[_("RouterLink",{attrs:{to:"/knowledge/design/行为型模式/迭代器模式/PHP实现.html"}},[t._v("PHP实现")])],1)])]),t._v(" "),_("h2",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),_("p",[t._v("迭代器模式的优点")]),t._v(" "),_("ul",[_("li",[t._v("它支持以不同的方式遍历一个聚合对象。")]),t._v(" "),_("li",[t._v("迭代器简化了聚合类。")]),t._v(" "),_("li",[t._v("在同一个聚合上可以有多个遍历。")]),t._v(" "),_("li",[t._v('在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足"开闭原则"的要求。')])]),t._v(" "),_("h2",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),_("p",[t._v("迭代器模式的缺点")]),t._v(" "),_("ul",[_("li",[t._v("由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。")])]),t._v(" "),_("h2",{attrs:{id:"适用环境"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[t._v("#")]),t._v(" 适用环境")]),t._v(" "),_("p",[t._v("在以下情况下可以使用迭代器模式：")]),t._v(" "),_("ul",[_("li",[t._v("访问一个聚合对象的内容而无须暴露它的内部表示。")]),t._v(" "),_("li",[t._v("需要为聚合对象提供多种遍历方式。")]),t._v(" "),_("li",[t._v("为遍历不同的聚合结构提供一个统一的接口。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);