(window.webpackJsonp=window.webpackJsonp||[]).push([[531],{901:function(v,_,e){"use strict";e.r(_);var c=e(28),o=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"react-工作循环-workloop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-工作循环-workloop"}},[v._v("#")]),v._v(" React 工作循环(workLoop)")]),v._v(" "),e("p",[v._v("在React应用的宏观包结构中，介绍了"),e("code",[v._v("react")]),v._v("核心包之间的依赖和调用关系，并绘制出了概览图。在概览图中，可以看到有两个大的循环，它们分别位于"),e("code",[v._v("scheduler")]),v._v("和"),e("code",[v._v("react-reconciler")]),v._v("包中：")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/core-packages.c2850581.png",alt:""}})]),v._v(" "),e("p",[v._v("本文将这两个循环分别表述为"),e("code",[v._v("任务调度循环")]),v._v("和"),e("code",[v._v("fiber构造循环")]),v._v("。接下来从宏观角度阐述这两大循环的作用，以及它们之间的区别和联系。更深入的源码分析分别在"),e("code",[v._v("scheduler 调度机制")]),v._v("和"),e("code",[v._v("fiber 树构造")]),v._v("章节中详细解读。")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("任务调度循环")])])]),v._v(" "),e("p",[v._v("源码位于"),e("code",[v._v("Scheduler.js")]),v._v("，它是"),e("code",[v._v("react")]),v._v("应用得以运行的保证，它需要循环调用，控制所有任务("),e("code",[v._v("task")]),v._v(")的调度。")]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("code",[v._v("fiber构造循环")])])]),v._v(" "),e("p",[v._v("源码位于"),e("code",[v._v("ReactFiberWorkLoop.js")]),v._v("，控制 fiber 树的构造，整个过程是一个深度优先遍历。")]),v._v(" "),e("p",[v._v("这两个循环对应的js源码不同于其他闭包(运行时就是闭包)，其中定义的全局变量，不仅是该作用域的私有变量，更用于"),e("code",[v._v("控制react应用的执行过程")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"区别和联系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别和联系"}},[v._v("#")]),v._v(" 区别和联系")]),v._v(" "),e("h3",{attrs:{id:"区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[v._v("#")]),v._v(" 区别")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("任务调度循环")]),v._v("是以"),e("code",[v._v("二叉堆")]),v._v("为数据结构（详见"),e("a",{attrs:{href:"./%E5%A0%86%E6%8E%92%E5%BA%8F"}},[v._v("react 算法之堆排序")]),v._v(")，循环执行"),e("code",[v._v("堆")]),v._v("的顶点，直到"),e("code",[v._v("堆")]),v._v("被清空。")]),v._v(" "),e("li",[e("code",[v._v("任务调度循环")]),v._v("的逻辑偏向宏观，它调度的是每一个任务("),e("code",[v._v("task")]),v._v(")，而不关心这个任务具体是干什么的(甚至可以将"),e("code",[v._v("Scheduler")]),v._v("包脱离"),e("code",[v._v("react")]),v._v("使用)，具体任务其实就是执行回调函数"),e("code",[v._v("performSyncWorkOnRoot")]),v._v("或"),e("code",[v._v("performConcurrentWorkOnRoot")]),v._v("。")]),v._v(" "),e("li",[e("code",[v._v("fiber构造循环")]),v._v("是以"),e("code",[v._v("树")]),v._v("为数据结构，从上至下执行深度优先遍历(详见"),e("a",{attrs:{href:"./%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"}},[v._v("react 算法之深度优先遍历")]),v._v(")")]),v._v(" "),e("li",[e("code",[v._v("fiber构造循环")]),v._v("的逻辑偏向具体实现，它只是任务("),e("code",[v._v("task")]),v._v(")的一部分(如"),e("code",[v._v("performSyncWorkOnRoot")]),v._v("包括："),e("code",[v._v("fiber")]),v._v("树的构造，"),e("code",[v._v("DOM")]),v._v("渲染，调度检测)，只负责"),e("code",[v._v("fiber")]),v._v("树的构造。")])]),v._v(" "),e("h3",{attrs:{id:"联系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联系"}},[v._v("#")]),v._v(" 联系")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("fiber构造循环")]),v._v("是"),e("code",[v._v("任务调度循环")]),v._v("中的任务("),e("code",[v._v("task")]),v._v(")的一部分。它们是从属关系，每个任务都会重新构造一个"),e("code",[v._v("fiber")]),v._v("树。")])]),v._v(" "),e("h2",{attrs:{id:"主干逻辑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主干逻辑"}},[v._v("#")]),v._v(" 主干逻辑")]),v._v(" "),e("p",[v._v("通过上文的描述，两大循环的分工可以总结为：大循环(任务调度循环)负责调度"),e("code",[v._v("task")]),v._v("，小循环(fiber 构造循环)负责实现"),e("code",[v._v("task")]),v._v("。")]),v._v(" "),e("p",[v._v("react 运行的主干逻辑，即将"),e("code",[v._v("输入转换为输出")]),v._v("的核心步骤，实际上就是围绕着两大工作循环进行展开。")]),v._v(" "),e("p",[v._v("结合上文的宏观概览图(展示核心包之间的调用关系)，可以将 react 运行的主干逻辑进行概括：")]),v._v(" "),e("ul",[e("li",[v._v("输入：将每一次更新(如：新增，删除，修改节点之后)视为一次"),e("code",[v._v("更新需求")]),v._v("(目的是要更新"),e("code",[v._v("DOM")]),v._v("节点)。")]),v._v(" "),e("li",[v._v("注册调度任务："),e("code",[v._v("react-reconciler")]),v._v("收到"),e("code",[v._v("更新需求")]),v._v("之后，并不会立即构造"),e("code",[v._v("fiber树")]),v._v("，而是去调度中心"),e("code",[v._v("scheduler")]),v._v("注册一个新任务"),e("code",[v._v("task")]),v._v("，即把"),e("code",[v._v("更新需求")]),v._v("转换成一个"),e("code",[v._v("task")]),v._v("。")]),v._v(" "),e("li",[v._v("执行调度任务(输出)：调度中心"),e("code",[v._v("scheduler")]),v._v("通过"),e("code",[v._v("任务调度系统")]),v._v("来执行"),e("code",[v._v("task")]),v._v("("),e("code",[v._v("task")]),v._v("的执行过程又回到了"),e("code",[v._v("react-reconciler")]),v._v("包中)。\n"),e("ul",[e("li",[e("code",[v._v("fiber构造循环")]),v._v("是"),e("code",[v._v("task")]),v._v("的实现环节之一，循环完成之后会构造出最新的fiber树。")]),v._v(" "),e("li",[e("code",[v._v("commitRoot")]),v._v("是"),e("code",[v._v("task")]),v._v("的实现环节之二，把最新的fiber树最终渲染到页面上，"),e("code",[v._v("task")]),v._v("完成。")])])])]),v._v(" "),e("p",[v._v("主干逻辑就是"),e("code",[v._v("输入到输出")]),v._v("这一条链路，为了更好的性能(如"),e("code",[v._v("批量更新")]),v._v("，"),e("code",[v._v("可中断渲染")]),v._v("等功能)，"),e("code",[v._v("react")]),v._v("在输入到输出的链路上做了很多优化策略，比如本文讲述的"),e("code",[v._v("任务调度循环")]),v._v("和"),e("code",[v._v("fiber构造循环")]),v._v("相互配合就可以实现"),e("code",[v._v("可中断渲染")]),v._v("。")]),v._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("p",[v._v("本文从宏观角度描述了"),e("code",[v._v("react")]),v._v("源码中的两大工作循环，通过这两个大循环概括出"),e("code",[v._v("react")]),v._v("运行的主干逻辑。"),e("code",[v._v("react-reconciler")]),v._v("和"),e("code",[v._v("Scheduler")]),v._v("包代码量多且逻辑复杂，但实际上大部分都是服务于这个主干，了解这两大循环，更容易理解"),e("code",[v._v("react")]),v._v("的整体运行链路。")])])}),[],!1,null,null,null);_.default=o.exports}}]);