(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{460:function(v,_,t){"use strict";t.r(_);var r=t(28),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"建造者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式"}},[v._v("#")]),v._v(" 建造者模式")]),v._v(" "),t("p",[t("code",[v._v("建造者模式")]),v._v("(Builder Pattern)又叫"),t("code",[v._v("生成器模式")]),v._v("。")]),v._v(" "),t("p",[v._v("建造者模式属于"),t("code",[v._v("对象创建型模式")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"模式动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式动机"}},[v._v("#")]),v._v(" 模式动机")]),v._v(" "),t("p",[v._v("无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，他们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户来说，无须知道这些步骤的装配细节，也几乎不会使用单独的某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，"),t("code",[v._v("建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象")]),v._v("。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。")]),v._v(" "),t("p",[v._v("在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象就不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。")]),v._v(" "),t("p",[v._v("复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被"),t("code",[v._v("外部化")]),v._v("到一个称作"),t("code",[v._v("建造者")]),v._v("的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。")]),v._v(" "),t("h2",{attrs:{id:"模式定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式定义"}},[v._v("#")]),v._v(" 模式定义")]),v._v(" "),t("p",[v._v("将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。")]),v._v(" "),t("p",[v._v("建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。")]),v._v(" "),t("h2",{attrs:{id:"模式结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式结构"}},[v._v("#")]),v._v(" 模式结构")]),v._v(" "),t("p",[v._v("建造者模式包含如下角色：")]),v._v(" "),t("ul",[t("li",[v._v("Builder：抽象建造者")]),v._v(" "),t("li",[v._v("ConcreteBuilder：具体建造者")]),v._v(" "),t("li",[v._v("Director：指挥者")]),v._v(" "),t("li",[v._v("Product：产品角色")])]),v._v(" "),t("h2",{attrs:{id:"代码实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[v._v("#")]),v._v(" 代码实现")]),v._v(" "),t("ul",[t("li",[t("RouterLink",{attrs:{to:"/knowledge/design/创建型模式/建造者模式/PHP实现.html"}},[v._v("PHP实现")])],1),v._v(" "),t("li",[t("RouterLink",{attrs:{to:"/knowledge/design/创建型模式/建造者模式/JS实现.html"}},[v._v("JS实现")])],1)]),v._v(" "),t("h2",{attrs:{id:"模式分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式分析"}},[v._v("#")]),v._v(" 模式分析")]),v._v(" "),t("p",[v._v("抽象建造者类中定义了产品的创建方法和返回方法。")]),v._v(" "),t("p",[v._v("建造者模式的结构中还引入了一个指挥者类Director，该类的主要作用有两个：")]),v._v(" "),t("ul",[t("li",[v._v("隔离了客户与生产过程")]),v._v(" "),t("li",[v._v("控制产品的生成过程")])]),v._v(" "),t("p",[v._v("指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。")]),v._v(" "),t("p",[v._v("在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开，这样使得同样的构建过程可以创建出不同的表现。")]),v._v(" "),t("h2",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),t("p",[v._v("建造者模式的优点：")]),v._v(" "),t("ul",[t("li",[v._v("在建造者模式中，"),t("strong",[v._v("客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象")]),v._v("。")]),v._v(" "),t("li",[v._v("每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便的替换具体建造者或增加新的具体建造者，"),t("strong",[v._v("用户使用不同的具体建造者即可得到不同的产品对象")]),v._v("。")]),v._v(" "),t("li",[t("strong",[v._v("可以更加精细地控制产品的创建过程")]),v._v("。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也方便使用程序来控制创建过程。")]),v._v(" "),t("li",[t("strong",[v._v("增加新的具体建造者无须修改修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合「开闭原则」")]),v._v("。")])]),v._v(" "),t("h2",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[v._v("#")]),v._v(" 缺点")]),v._v(" "),t("p",[v._v("建造者模式的缺点：")]),v._v(" "),t("ul",[t("li",[v._v("建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大， 则不适合使用建造者模式，因此其使用范围受到一定的限制。")]),v._v(" "),t("li",[v._v("如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。")])]),v._v(" "),t("h2",{attrs:{id:"适用环境"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#适用环境"}},[v._v("#")]),v._v(" 适用环境")]),v._v(" "),t("p",[v._v("在以下情况下可以使用建造者模式：")]),v._v(" "),t("ul",[t("li",[v._v("需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。")]),v._v(" "),t("li",[v._v("需要生成的产品对象的属性相互依赖，需要指定其生成顺序。")]),v._v(" "),t("li",[v._v("对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。")]),v._v(" "),t("li",[v._v("隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。")])]),v._v(" "),t("h2",{attrs:{id:"模式应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式应用"}},[v._v("#")]),v._v(" 模式应用")]),v._v(" "),t("p",[v._v("在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。")]),v._v(" "),t("h2",{attrs:{id:"模式扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式扩展"}},[v._v("#")]),v._v(" 模式扩展")]),v._v(" "),t("p",[v._v("建造者模式的简化：")]),v._v(" "),t("ul",[t("li",[v._v("省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。")]),v._v(" "),t("li",[v._v("省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者和建造者双重角色。")])]),v._v(" "),t("p",[v._v("建造者模式与抽象工厂模式的比较：")]),v._v(" "),t("ul",[t("li",[v._v("与抽象工厂模式相比，"),t("strong",[v._v("建造者模式返回一个组装好的完整产品")]),v._v("，而"),t("strong",[v._v("抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族")]),v._v("。")]),v._v(" "),t("li",[v._v("在抽象工厂模式中，客户端实例工厂化类，然后调用工厂方法获取所需产品对象，而建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。")]),v._v(" "),t("li",[v._v("如果将抽象工厂模式看成"),t("strong",[v._v("汽车配件生产工厂")]),v._v("，生产一个产品族的产品，那么建造者模式就是一个"),t("strong",[v._v("汽车组装工厂")]),v._v("，通过对部件的组装可以返回一辆完整的汽车。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);