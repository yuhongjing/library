(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{575:function(t,s,a){"use strict";a.r(s);var v=a(27),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"回溯法原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回溯法原理"}},[t._v("#")]),t._v(" 回溯法原理")]),t._v(" "),a("p",[t._v("学习正则表达式，是需要懂点儿匹配原理的。")]),t._v(" "),a("p",[t._v("而研究匹配原理时，有两个字出现的频率比较高："),a("code",[t._v("回溯")]),t._v("。")]),t._v(" "),a("p",[t._v("听起来挺高大上，事实上却是一个比较容易理解的概念。")]),t._v(" "),a("h2",{attrs:{id:"没有回溯的匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#没有回溯的匹配"}},[t._v("#")]),t._v(" 没有回溯的匹配")]),t._v(" "),a("p",[t._v("假设我们的正则是"),a("code",[t._v("/ab{1, 3}c/")])]),t._v(" "),a("p",[t._v('当目标字符串是"abbbc"时，就没有所谓的"回溯"。其匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219193937.png",alt:""}})]),t._v(" "),a("p",[t._v("其中子表达式"),a("code",[t._v("b{1, 3}")]),t._v('表示"b"字符连续出现1到3次。')]),t._v(" "),a("h2",{attrs:{id:"有回溯的匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有回溯的匹配"}},[t._v("#")]),t._v(" 有回溯的匹配")]),t._v(" "),a("p",[t._v('如果目标字符串是"abbc"，中间就有回溯。')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219194104.png",alt:""}})]),t._v(" "),a("p",[t._v("图中第5步有红颜色，表示匹配不成功。此时"),a("code",[t._v("b{1, 3}")]),t._v('已经匹配到了2个字符"b"，准备尝试第三个时，结果发现接下来的字符是"c"。那么就认为'),a("code",[t._v("b{1, 3}")]),t._v('就已经匹配完毕。然后状态又回到之前的状态(即第6步与第4步一样)，最后再用子表达式c，去匹配字符"c"。当然，此时整个表达式就匹配成功了。')]),t._v(" "),a("p",[t._v('图中的第6步，就是"回溯"。')]),t._v(" "),a("p",[t._v("你可能对此没有感觉，这里我们再举一个例子。")]),t._v(" "),a("p",[t._v("正则是"),a("code",[t._v("/ab{1, 3}bbc/")]),t._v("目标字符串是"),a("code",[t._v("abbbc")]),t._v("，匹配过程是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219194707.png",alt:""}})]),t._v(" "),a("p",[t._v("其中的第7步和第10步是回溯。第7步与第4步一样，此时"),a("code",[t._v("b{1, 3}")]),t._v('匹配了两个"b"，而第10步与第3步一样，此时'),a("code",[t._v("b{1, 3}")]),t._v('只匹配了一个"b"，这也是'),a("code",[t._v("b{1, 3}")]),t._v("的最终匹配结果。")]),t._v(" "),a("p",[t._v("这里再来看一个清晰的回溯。")]),t._v(" "),a("p",[t._v("正则是"),a("code",[t._v('/".*"/')]),t._v("，目标字符串是:"),a("code",[t._v('"abc"de')]),t._v("，匹配过程是：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219194939.png",alt:""}})]),t._v(" "),a("p",[t._v("图中省略了尝试匹配双引号失败的过程。可以看出"),a("code",[t._v(".*")]),t._v("是非常影响效率的。")]),t._v(" "),a("p",[t._v("为了减少一些不必要的回溯，可以把正则修改为"),a("code",[t._v('/"[^"]*"/')]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"常见的回溯形式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的回溯形式"}},[t._v("#")]),t._v(" 常见的回溯形式")]),t._v(" "),a("p",[t._v("正则表达式匹配字符串的这种方式，有个学名，叫"),a("code",[t._v("回溯法")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v('回溯法也称试探法，它的基本思想是：从问题的某一种状态(初始状态)出发，搜索从这种状态出发所能达到的所有"状态"，当一条路走到"尽头"的时候(不能再前进)，再后退一步或若干步，从另一种可能"状态"出发，继续搜索，直到所有的"路径"(状态)都试探过。这种不断"前进"、不断"回溯"寻找解的方法，就称作"回溯法"。')]),t._v(" "),a("p",[t._v("---- 百度百科")])]),t._v(" "),a("p",[t._v("本质上就是"),a("code",[t._v("深度优先搜索算法")]),t._v('。其中退到之前的某一步这一过程，我们称为"回溯"。从上面的描述过程中，可以看出，路走不通时，就会发生"回溯"。即，尝试匹配失败时，接下来的一步通常就是回溯。')]),t._v(" "),a("p",[t._v("道理，我们是懂了。那么JavaScript中正则表达式会产生回溯的地方都由哪些呢？")]),t._v(" "),a("h3",{attrs:{id:"贪婪量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#贪婪量词"}},[t._v("#")]),t._v(" 贪婪量词")]),t._v(" "),a("p",[t._v("之前的例子都是贪婪量词相关的。比如"),a("code",[t._v("b{1, 3}")]),t._v('，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试"bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个"b"，即在"bb"的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。')]),t._v(" "),a("p",[t._v("虽然局部匹配是贪婪的，但也要满足整体能正确匹配。否则，皮之不存，毛将焉附？")]),t._v(" "),a("p",[t._v("此时我们不禁会问，如果当多个贪婪量词挨着存在，并相互有冲突时，此时会是怎样？")]),t._v(" "),a("p",[t._v("答案是，先下手为强！因为深度优先搜索。测试如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"12345"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1, 3})(\\d{1, 3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["12345", "123", "45", index: 0, input: "12345"]')]),t._v("\n")])])]),a("p",[t._v("其中，前面的"),a("code",[t._v("\\d{1, 3}")]),t._v('匹配的是"123"，后面的'),a("code",[t._v("\\d{1, 3}")]),t._v('匹配的是"45"。')]),t._v(" "),a("h3",{attrs:{id:"惰性量词"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#惰性量词"}},[t._v("#")]),t._v(" 惰性量词")]),t._v(" "),a("p",[t._v("惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"12345"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" regex "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/(\\d{1, 3}?)(\\d{1, 3})/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("regex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// => ["1234", "1", "234", index: 0, input: "12345"]')]),t._v("\n")])])]),a("p",[t._v("其中"),a("code",[t._v("\\d{1, 3}?")]),t._v('只匹配到一个字符"1"，而后面的'),a("code",[t._v("\\d{1, 3}")]),t._v('匹配了"234"。')]),t._v(" "),a("p",[t._v("虽然惰性量词不贪，但也会有回溯的现象。")]),t._v(" "),a("p",[t._v("比如正则是"),a("code",[t._v("/^\\d{1, 3}?\\d{1, 3}$/")]),t._v('，目标字符串是"12345"，匹配过程是：')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219201523.png",alt:""}})]),t._v(" "),a("p",[t._v("知道你不贪、很知足，但是为了整体匹配成功，没办法，也只能给你多赛点了。因此最后"),a("code",[t._v("\\d{1, 3}?")]),t._v('匹配的字符是"12"，是两个数字，而不是一个。')]),t._v(" "),a("h3",{attrs:{id:"分支结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支结构"}},[t._v("#")]),t._v(" 分支结构")]),t._v(" "),a("p",[t._v("我们知道分支也是惰性的，比如"),a("code",[t._v("/can|candy/")]),t._v('，去匹配字符串"candy"，得到的结果是"can"，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。')]),t._v(" "),a("p",[t._v("分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，扔会继续尝试剩下的分支。这种尝试也可以看成一种回溯。")]),t._v(" "),a("p",[t._v("比如正则"),a("code",[t._v("/^(can|candy)$/")]),t._v('，目标字符串是"candy"，匹配过程：')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/yuhongjing/img-folder/master/img/20191219201909.png",alt:""}})]),t._v(" "),a("p",[t._v("上面的第5步，虽然没有回到之前的状态，但仍然回到了分支结构，尝试下一种可能。所以，可以认为它是一种回溯的。")]),t._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),a("p",[t._v("其实回溯法，很容易掌握的。")]),t._v(" "),a("p",[t._v("简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了；要么最后都试完后，发现整体匹配不成功。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v('贪婪量词"试"的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。')])]),t._v(" "),a("li",[a("p",[t._v('惰性量词"试"的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。')])]),t._v(" "),a("li",[a("p",[t._v('分支结构"试"的策略是：货币三家。这家不行，换一家吧，还不行，再换。')])])]),t._v(" "),a("p",[t._v('既然有回溯的过程，那么匹配效率肯定低一些。相对谁呢？相对那些DFA引擎，DFA是"确定型有限自动机"的简写。')]),t._v(" "),a("p",[t._v('而JavaScript的正则引擎是NFA，NFA是"非确定性有限自动机"的简写。')]),t._v(" "),a("p",[t._v("大部分语言中的正则都是NFA，为啥它这么流行呢？")]),t._v(" "),a("p",[t._v("答：你别看我匹配慢，但是我编译快啊，而且我还有趣哦。")])])}),[],!1,null,null,null);s.default=_.exports}}]);