(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{591:function(e,t,s){"use strict";s.r(t);var r=s(27),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),s("p",[e._v("模块化的引入主要是用于解决命名冲突、代码复用、代码可读性、依赖管理等。")]),e._v(" "),s("p",[e._v("目前有AMD、CMD、CommonJS与ES6等模块规范。")]),e._v(" "),s("h2",{attrs:{id:"amd异步模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#amd异步模块"}},[e._v("#")]),e._v(" AMD异步模块")]),e._v(" "),s("p",[e._v("AMD全称Asynchronous Module Definition（异步模块定义）。")]),e._v(" "),s("p",[e._v("AMD并非原生JS支持，是Require JS模块化开发当中推广的产物，AMD依赖于Require JS函数库，打包生成对应效果的JS代码。")]),e._v(" "),s("p",[e._v("Require JS主要用于解决多个js文件之间的依赖关系、浏览器加载大量js代码导致无响应、异步加载模块。")]),e._v(" "),s("p",[e._v("Require JS通过"),s("code",[e._v("define(id?,dependencies?,factory)")]),e._v("定义模块，id可选，为定义模块的标识，默认为模块文件名不包括后缀，dependencies可选，是当前模块依赖的模块路径数组，factory为工厂方法，初始化模块的函数或者对象，如果为函数将会只执行一次，如果是对象将作为模块的输出")]),e._v(" "),s("p",[e._v("通过"),s("code",[e._v("require(dependencies, factory)")]),e._v("导入模块，其中dependencies为需要导入的模块路径数组，factory为模块导入之后的回调函数，此函数的参数列表为对应导入的模块")]),e._v(" "),s("p",[e._v("通过require.config(配置对象)配置各模块路径和引用名")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[e._v("require"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("config")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  baseUrl"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'js/lib'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  paths"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'jquery'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'jquery.min'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 实际路径为js/lib/jquery.min.js")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'underscore'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'underscore.min'")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),s("h2",{attrs:{id:"cmd通用模块定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cmd通用模块定义"}},[e._v("#")]),e._v(" CMD通用模块定义")]),e._v(" "),s("p",[e._v("CMD全称Common Module Definition，通用模块定义")]),e._v(" "),s("p",[e._v("同AMD，CMD也有一个函数库SeaJS和RequireJS类似的功能")]),e._v(" "),s("p",[e._v("CMD推崇一个文件一个模块，推崇依赖就近，定义模块"),s("code",[e._v("define(id?, dep?, factory)")]),e._v("，id同AMD，deps一般不在其中写依赖，而是在factory中需要使用的时候引入模块，factory函数接收3个参数：")]),e._v(" "),s("ul",[s("li",[e._v("require方法，用来内部引入模块的时候调用；")]),e._v(" "),s("li",[e._v("exports是一个对象，用来向外部提供模块接口；")]),e._v(" "),s("li",[e._v("module是一个对象，存储了与当前模块相关联的一些属性和方法")])]),e._v(" "),s("p",[e._v("通过"),s("code",[e._v("seajs.use(deps, func)")]),e._v("加载模块，deps为引入到模块路径数组，func为加载完成后的回调函数。")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块")])]),e._v(" "),s("li",[s("p",[e._v("CMD推崇就近依赖，只有在用到某个模块的时候再去require")])])]),e._v(" "),s("h2",{attrs:{id:"commonjs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),s("p",[e._v("CommonJS模块规范，通常用于Nodejs中的模块化")]),e._v(" "),s("p",[e._v("拥有4个环境变量module、exports、require、global")]),e._v(" "),s("p",[e._v("通过"),s("code",[e._v("module.exports")]),e._v("(不推荐exports)导出模块对象，通过require(模块路径)加载模块")]),e._v(" "),s("p",[e._v("当一个模块同时存在exports和module.exports时，后者会覆盖前者")]),e._v(" "),s("p",[e._v("规范中"),s("code",[e._v("__dirname")]),e._v("代表当前模块文件所在的文件夹路径，"),s("code",[e._v("__filename")]),e._v("代表当前模块文件夹路径+文件名")]),e._v(" "),s("p",[e._v("CommonJS通过同步的方式加载模块，其输出的模块是一个拷贝对象，所以修改原模块不会对被引入的模块内部产生影响，且模块在运行的时候加载。")]),e._v(" "),s("h2",{attrs:{id:"es6模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6模块化"}},[e._v("#")]),e._v(" ES6模块化")]),e._v(" "),s("p",[e._v("es6引入的export与import用于解决js自身不具备模块功能的缺陷")]),e._v(" "),s("p",[e._v("通过export或者export default导出模块接口，通过import xxx from '路径'，导入模块")]),e._v(" "),s("p",[e._v("对于export导出的接口可以使用import {接口} from '路径',通过解构的方式按需导入")]),e._v(" "),s("p",[e._v("对于export default默认导出的，可以使用import xxx from '路径'，来导入默认导出的接口，xxx可以是自定义名称，且一个模块只能有一个默认导出，可以有多个export")]),e._v(" "),s("p",[e._v("还可以通过别名的方式设置导出和导入的接口名，如export {a as foo}，把foo作为a的别名导出，import foo as b from 路径，把b当作foo的别名导入。")]),e._v(" "),s("p",[e._v("es6模块是在代码编译时输出接口即编译时加载，es6是通过命令来指定导出和加载，且导出的是模块中的只读引用，如果原始模块中的值被改变了，那么加载的值也会随之改变，所以是动态引用。")])])}),[],!1,null,null,null);t.default=a.exports}}]);