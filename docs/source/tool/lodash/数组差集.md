---
title: 数组差集
---

# 数组差集

```js
function differenceBy(array, ...values) {
  let iteratee = last(values);
  if (isArrayLikeObject(iteratee)) {
    iteratee = undefined;
  }
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), iteratee)
    : [];
}
```

这一段比较有意思的地方在于。

目标为：参数不固定的情况下，获取最后一个参数作为迭代器。但是这个迭代器不是必传的，因此需要区分。

区分步骤如下：

* 获取最后一个参数，返回为一个新的变量Tag保存。
* 判断是否为数组对象，如果是则Tag为`undefined`，表示无迭代器。
* 求差集
  * 若需要迭代器，则values数组最后一个参数类型为函数，则这个参数无法通过`baseFlatten(values, 1, isArrayLikeObject, true)`中的`isArrayLikeObject`校验，从而被过滤。
  * 若不需要迭代器，则`baseDifference`函数第三个参数为`undefined`，表示无迭代器，并且因为数组全部数据都符合过滤规范，从而不会被过滤。

比较精妙的控制了，数组存在两种类型时的不同处理。