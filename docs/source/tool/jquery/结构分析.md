---
title: 结构分析
---

# 结构分析

分析jQuery重要功能，核心设计的实现。

## IIFE（立即调用函数表达式，也称为自执行匿名函数）

ES2015之前，JS没有模块化的概念，因此每个库的代码，无法阻止外界访问，而且库中变量也会污染全局作用域。

因此，那个时期的JS库，多是采用IIFE的模式，来隔绝对库的访问和保证库独立性。


```js
// 通过IIFE的方式，实现库代码与外部环境代码的隔离
(function( global, factory ) {
  // 支持CommandJS方式引用jQuery
  if ( typeof module === "object" && typeof module.exports === "object" ) {
    // 查看当前环境是否存在document属性
    module.exports = global.document ?
      // 因为模块化的原因，这里第二个参数传送了true
      // 因此不会在global对象上绑定$和jQuery属性，仅返回jQuery函数
      // var jQuery = require("jquery")(window);
      factory( global, true ) :
			function( w ) {
        // Node.js环境则直接报错
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
        }
				return factory( w );
			};
	} else {
		factory( global );
	}
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
  // ... jQuery核心代码
  return jQuery;
}));
```

## JS全局对象绑定jQuery

jQuery是如何绑定在window对象中的呢？

在IIFE中，会将window引用传入到jQuery函数中，并根据noGlobal来判断，是否需要将jQuery绑定在全局对象上。


```js
if ( !noGlobal ) {
  // 这里占用全局对象的jQuery属性和$属性
	window.jQuery = window.$ = jQuery;
}
```

## jQuery.noConflict 释放占用属性

jQuery默认占用全局对象window中jQuery与$两个属性。

如果我们还引用了其他三方库，且三方库也需要占用$属性，这时就会产生冲突。

因此，jQuery提供释放属性的功能，默认会释放$属性。如果传入参数`true`，则会将jQuery属性也释放掉。


```js
var
	// 保存被jQuery覆盖之前的jQuery值
	_jQuery = window.jQuery,

	// 保存被jQuery覆盖之前的$值
	_$ = window.$;

// 释放jQuery占用的$和jQuery属性
// deep：布尔值，为true时，会释放jQuery属性
jQuery.noConflict = function( deep ) {
  // $属性被jQuery占用时，将其还原为覆盖之前的对象
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

  // jQuery属性被jQuery占用时，将其还原为覆盖之前的对象
	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};
```

## 无new构造jQuery

无new构造算是jQuery的亮点之一了。

后续的三方库，例如Axios等，应该也或多或少的借鉴了jQuery的实现方法。


```js
// Axios实现无new构造的方法为：
// 1. 用户导入的axios并非是真正的Axios类，而是一个封装函数
// 2. 在此函数内部，实例化new Axios，生成真正的实例对象
// 3. 将真正的实例对象的原型方法和属性绑定在封装函数上
// 4. 返回这个封装函数，因此可以无new，即可调用Axios类上的原型方法和属性了

// jQuery相对绕一点
// 但是核心逻辑，还是通过一个封装函数来绑定实例原型实现的
// 其实通过以下几句代码，即可实现
var jQuery = function( selector, context ) {
	return new jQuery.fn.init( selector, context );
};

var init = jQuery.fn.init = function( selector, context, root ) {
  // ...
};

init.prototype = jQuery.fn;
```

1. jQuery是函数，在其内部返回实例化的jQuery原型函数init
2. init函数原型绑定为jQuery的原型，因此实例化init函数时，就可以访问jQuery的原型方法

如果对原型链熟悉，那么这段代码应该非常好理解。
