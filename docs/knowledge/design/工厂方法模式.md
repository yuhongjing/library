---
title: 工厂方法模式
---

# 工厂方法模式
`简单工厂模式`会存在以下问题:
* 工厂类集中了所有类的创建逻辑，一但这个工厂出错，整个系统都会受到影响
* 违背"开发 - 关闭原则"，一但添加新类就得修改工厂类
* 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构

`工厂方法模式`，又称工厂模式、多态工厂模式和虚拟构造器模式，通过工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

工厂方法模式属于`创建型模式`，主要是解决`简单工厂模式`的缺点。

## 适用场景
同`简单工厂模式`场景，且更复杂的场景。

## 核心思想
每一个类都创建一个工厂。

## 举例说明
还是同`简单工厂模式`一样的例子，通过`工厂方法模式`来实现。
```js
class popFactory {
    createPop(options) {}
}

class AlertFactory extends popFactory {
    createPop(options) {
        return new Alert(options);
    }
}

class PromptFactory extends popFactory {
    createPop(options) {
        return new Prompt(options);
    }
}

class ConfirmFactory extends popFactory {
    createPop(options) {
        return new Confirm(options);
    }
}

// 使用
const factory = new AlertFactory(); // 如需更改，可以只替换这里
const pop1 = factory.createPop();
const pop2 = factory.createPop();
const pop3 = factory.createPop();

// new Alert().createPop('提示信息');
```

## 总结
`工厂方法模式`克服了`简单工厂模式`违背`开放-封闭`的缺点，又保持了封装对象创建的优点，是简单工厂模式的进一步抽象和扩展，使得扩展简更简单、继承变得可行、增加了多态性的体现。  

但缺点是每增加一个类就得新添一个工厂类。

::: tip 注意
这里可能会产生错觉，为什么不直接`new`生成实例，而需要通过工厂呢？
* 降低程序耦合性
* 生成实例可能不仅仅是一句`new`即可，很多场景生成一个实例会需要很多的流程，这时通过工厂模式就能减少大量的代码了 
:::
