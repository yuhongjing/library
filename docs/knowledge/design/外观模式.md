---
title: 外观模式
---

# 外观模式

`外观模式`(Facade Pattern)是一种使用频率非常高的设计模式，它通过引入一个`外观角色`来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，隐藏了系统的复杂性，且客户端调用非常方便。

`外观模式`又称为`门面模式`，属于`对象结构型模式`。外观模式是`迪米特法则`的一种具体实现。



## 适用场景

* 为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式
* 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性
* 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度



## 核心思想

外观模式的本质是: `封装交互，简化调用`。

通过引入一个新的外观角色来处理外部和子系统的交互，目的不是给予子系统新的功能，而是为了减少子系统和外部的交互，松散耦合，从而使外部更简单的使用子系统。



## 举例说明

电脑`整机`就是CPU、内存、硬盘的`外观类`。有了外观以后，启动电脑和关闭电脑都简化了。

原本开(关)机的步骤:

* 启动(关闭)CPU
* 启动(关闭)内存
* 启动(关闭)硬盘

而有了`外观`类电脑整机后，开关闭步骤简化:

* 点击机箱电源按钮(暴露的方法) : 相当于执行了CPU、内存、硬盘的开关

实现方式如下:

```js
class Computer {
    open() {}
}

class Cpu extends Computer {
    open() {
        console.log('启动CPU');
    }
}

class Ddr extends Computer {
    open() {
        console.log('启动内存');
    }
}

class Ssd extends Computer {
    open() {
        console.log('启动硬盘');
    }
}

// 外观类
class Facade {
    open() {
        const cpu = new Cpu();
        const ddr = new Ddr();
        const ssd = new Ssd();
        cpu.open();
        ddr.open();
        ssd.open();
    }
}

// 客户端
// 不使用外观的情况下
const cpu = new Cpu();
cpu.open(); // 启动CPU
const ddr = new Ddr();
ddr.open(); // 启动内存
const ssd = new Ssd();
ssd.open(); // 启动硬盘

// 使用外观的情况下
const facade = new Facade();
facade.open(); // 启动CPU 启动内存 启动硬盘
```

使用外观类，依旧完成原本的功能，但是`减少`了外部和系统的交互，还`隔离`了外部和系统的交互。



## 总结

优点:

* 减少系统相互依赖
* 提高灵活性
* 提高安全性

缺点:

* 不符合开闭原则，子系统更改，外观层也得更改
* 限制了客户端直接访问子系统类