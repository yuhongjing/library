---
title: 装饰者模式
---

# 装饰者模式
`装饰者模式`(decorator)能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。  
与继承相比，装饰者模式是一种更轻便灵活的做法。
  
装饰者模式属于`结构型模式`。

## 适用场景
在传统面对对象语言中，为对象添加功能常使用继承，但继承有很多缺点:
* 超类子类强耦合，超类改变导致子类改变
* 超类内部细节对子类可见，破坏了封闭性
* 完成功能复用的同时，可能会创造大量子类

而装饰者模式是在`不改变对象自身的基础上`添加职责，所以不会出现以上的问题。

## 核心思想
`装饰器类`要维护一个目标对象的引用，同时要实现目标类的`所有接口`。  
调用方法时，先执行目标对象的原有的方法，在执行自行添加的特性。

当接口比较多，装饰器也比较多时，可以独立抽取一个`装饰器父类`，实现目标类的所有接口，再创建真正的装饰器来继承这个父类。

## 举例说明
简单需求下的装饰者模式
```js
class Person {
    constructor(name) {
        this.name = name;
    }
    run() {
      return this.name + '能够奔跑';
    }
    eat() {
      return this.name + '需要吃饭';
    }
}

const xiaoming = new Person('小明');
console.log(xiaoming.run()); // 小明能够奔跑
console.log(xiaoming.eat()); // 小明能够吃饭

// 装饰器类
class Decorator {
    constructor(object) {
        this.object = object;
    }
    run() {
      // 装饰奔跑
      return this.object.run() + '在大草原上';
    }
    eat() {
      // 装饰吃饭
      return this.object.eat() + '而且能吃好几碗';
    }
}

const xiaomingDeco = new Decorator(new Person('小明'));
console.log(xiaomingDeco.run()); // 小明能够奔跑在大草原上
console.log(xiaomingDeco.eat()); // 小明需要吃饭而且能吃好几碗
```

复杂需求下，很多装饰器的情况
```js
class Car {
    driver() {
        return '开车';
    }
    brake() {
        return '刹车';
    }
}

// 所有装饰器的父类
class CarDecorator {
    constructor(car) {
        this.car = car;
    }
    driver() {
        return this.car.driver();
    }
    brake() {
        return this.car.brake();
    }
}

// 真正的装饰器
class AutoDecorator extends CarDecorator {
    driver() {
        console.log('启动自动驾驶模式');
        return this.car.driver();
    }
}

// 真正的装饰器
class HybridDecorator extends CarDecorator {
    brake() {
        console.log('启动充电模式');
        return this.car.brake();
    }
}

const car = new Car();
const autoCar = new AutoDecorator(car);
console.log(autoCar.driver()); // 启动自动驾驶模式 开车
const hybridCar = new HybridDecorator(car);
console.log(hybridCar.brake()); // 启动充电模式 刹车
```

## 总结
扩展了类的功能

* 装饰链叠加了函数作用域，如果过长也会产生性能问题。  
* 如果原函数上保存了属性，返回新函数后属性会丢失。  
* 装饰者模式在开发中非常有用，在框架开发中也十分有用。

装饰者模式的优点  
就是有效把类的核心职责和装饰功能区分开，还可以去除相关类中重复的装饰逻辑。