---
title: 代理模式
---

# 代理模式
`代理模式`(Proxy)，为其他对象提供一种代理以控制对这个对象的访问。  

代理模式属于`结构型模式`。

## 使用场景
通常在如下场景时，需要使用到代理模式。  
* 无法直接访问某个对象
* 不想直接访问某个对象
* 访问某个对象存在困难

## 种类
代理模式分为`静态代理`和`动态代理`。

### 静态代理
什么是`静态代理`？若代理类在程序运行之前已经存在，那么这种代理方式被称为`静态代理`。  
下面是一个大明星想买鞋，通过助理来实现的代码。
```js
class Star {
    buyShoes() {
        console.log("买了一双鞋");
    }
}

class Assistant {
    buyShoes() {
        // 这里还可以添加各种过滤条件
        new Star().buyShoes();
    }
}

// 客户端代码
new Assistant().buyShoes(); // 买了一双鞋
```
这里的助理类，就相当于代理类，并且在代理类中可以添加更多的功能，例如`过滤`等功能。  
它的缺点很明显：
* 需要`代理类`实现与`目标类`相同的方法
* 每一个`代理类`只能代理一个`目标类`。

所以当有多个需要代理的`目标类`时，就得重复书写很多代码。  
而解决这个问题的办法就是`动态代理`。

### 动态代理
什么是`动态代理`，代理类在程序运行时创建的，这种代理方式称为`动态代理`。  
`动态代理`需要一个`生成代理的类`来动态生成代理类。  
**还没学习反射，先学习反射再回头看这里吧。待续**

## 静态代理模式与装饰者模式的区别
装饰者模式中`客户端`的代码必须知道`被装饰者类`并且得生成它的`实例`。  
而静态代理模式中，`客户端`是完全不知道`真实目标对象`，更别说生成它的实例了。  

装饰模式主要是强调对类中代码的`拓展`，而代理模式则偏向于委托类的`访问限制`

## 总结
代理模式，主要就是为了防止`客户端`能够直接访问到`目标对象`所做的一层隔离。