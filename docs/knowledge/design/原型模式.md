---
title: 原型模式
---

# 原型模式
`原型模式`(Prototype)指用原型实例指定创造对象的种类，并且通过拷贝这些原型创建新的对象。

`原型模式`是一种`创建型设计模式`，`Prototype`模式允许一个对象再创建另外一个可定制的对象，无需知道任何创建的细节。

## 适用场景
创建多个类似的大对象时，如果直接通过`new`对象，开销很大而且`new`完还得进行重复的初始化工作。而通过`原型模式`就可以先创建好一个原型对象，然后`clone`这个原型对象来创建新的对象，这样免去了重复的初始化工作，系统仅需内存拷贝即可。

## 核心思想
通过将一个原型对象传给那个要创建的对象，这个要创建的对象通过请求`原型对象`拷贝它们自己来实施创建。

## 举例说明
因为`js`是基于`原型链继承`的语言，不如其他语言描述明了，所以本例通过`php`描述。

### 浅copy模式
直接copy，拷贝了源对象的`引用地址`等，所以源对象变化，拷贝的也会变化。
```php
<?php

interface Prototype
{
    public function copy();
}

/* 测试浅拷贝 */
class DeepCopyDemo{
    public $array;
}

class CreatePrototype implements Prototype
{
    private $name;

    public function __construct($name) {
        $this->name = $name;
    }

    public function setName($name) {
        $this->name = $name;
    }

    public function getName() {
        return $this->name;
    }

    /* 关键的拷贝函数 */
    public function copy() {
        return clone $this;
    }
}

// 客户端测试
$user_1 = new CreatePrototype('小明');
$user_2 = $user_1->copy(); // 拷贝
$user_2->setName('小红');

echo $user_1->getName(); // 小明
echo '<br />';
echo $user_2->getName(); // 小红
echo '<br />';

// 上面一切都很正常，但是当源对象的值为引用类型时
$notDeepClone = new DeepCopyDemo();
$notDeepClone->array = array(1, 2);

$user_3 = new CreatePrototype($notDeepClone); // 新生成对象
$user_4 = $user_3->copy();

var_dump($user_3->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(1) [1]=> int(2) } }
echo '<br />';
var_dump($user_4->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(1) [1]=> int(2) } }
echo '<br />';

// 此时改变引用值
$notDeepClone->array = array(3, 4);
var_dump($user_3->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(3) [1]=> int(4) } }
echo '<br />';
// 拷贝的对象也跟随改变了
var_dump($user_4->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(3) [1]=> int(4) } }
```

### 深拷贝模式
深拷贝通过序列化和反序列化完成copy，新对象完全复制原来的对象，并且源对象改变，新对象不变。

```php
<?php

interface Prototype
{
    public function copy();
}

/* 测试浅拷贝 */
class DeepCopyDemo{
    public $array;
}

class CreatePrototype implements Prototype
{
    private $name;

    public function __construct($name) {
        $this->name = $name;
    }

    public function setName($name) {
        $this->name = $name;
    }

    public function getName() {
        return $this->name;
    }

    /* 关键的拷贝函数 */
    public function copy() {
        $serialize_obj = serialize($this);
        $clone_obj = unserialize($serialize_obj);
        return $clone_obj;
    }
}

// 客户端测试
$notDeepClone = new DeepCopyDemo();
$notDeepClone->array = array(1, 2);

$user_3 = new CreatePrototype($notDeepClone); // 新生成对象
$user_4 = $user_3->copy();

var_dump($user_3->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(1) [1]=> int(2) } }
echo '<br />';
var_dump($user_4->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(1) [1]=> int(2) } }
echo '<br />';

// 此时改变引用值
$notDeepClone->array = array(3, 4);
var_dump($user_3->getName()); // object(DeepCopyDemo)#3 (1) { ["array"]=> array(2) { [0]=> int(3) [1]=> int(4) } }
echo '<br />';
// 拷贝的对象不会跟随改变了
var_dump($user_4->getName()); // object(DeepCopyDemo)#4 (1) { ["array"]=> array(2) { [0]=> int(1) [1]=> int(2) } }
```

::: tip 注释
利用序列化来做深拷贝，把对象写到流里的过程是序列化的过程。   
这一过程称为“冷冻”或“腌咸菜”，反序列化对象的过程叫做「解冻」或「回鲜」。  
其实在`js`中的深拷贝也是这个思路。
:::

## 总结
`原型模式`就是需要在每一个类中配备一个克隆的方法。  
利用克隆来生成对象，减少创建时的初始化等操作开销。