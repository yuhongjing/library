---
title: 策略模式
---

# 策略模式
`策略模式`(Strategy)，定义了算法家族，分别封装起来，让它们之前可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。  

策略模式是一种`行为型模式`，适用于一个功能有多种途径解决的场景。

## 适用场景
主要用于`封装一系列的算法`。  
计算两个数字时，有`加`、`减`、`乘`、`除`等算法，他们之间仅仅是行为的区别。  
这种情况下可以通过`if...else`或`switch`来区分。  
但其实我们也可以通过策略模式来实现算法的替换，从而避免`if...else`所带来的复杂和难以维护。

## 核心思想
`策略模式`的核心思想，封装不同策略的`策略组`和`Context`。  
通过组合和委托让`Context`拥有执行策略的能力，从而实现可复用、可扩展和可维护，并且避免大量复制粘贴的工作。

## 举例说明
两数操作，最基本的实现。
```js
function operation(op, num1, num2) {
    switch (op) {
        case '+': return num1 + num2;
        case '-': return num1 - num2;
        case '*': return num1 * num2;
        case '/': return num1 / num2; // 不考虑为0的情况
        default: return null;
    }
}

operation('+', 3, 5); // 8
operation('-', 3, 5); // -2
```

通过`策略模式`来实现。
```js
// 上下文
class Context {
    constructor(strategy) {
        this.strategy = strategy;
    }

    executeStrategy(num1, num2) {
        return this.strategy.doOperation(num1, num2);
    }
}

// 策略组接口
class StrategyOperation {
    doOperation(num1, num2) {}
}

// 单独策略
class AddOperation extends StrategyOperation {
    doOperation(num1, num2) {
        return num1 + num2;
    }
}
class SubtractOperation extends StrategyOperation {
    doOperation(num1, num2) {
        return num1 - num2;
    }
}

let context = new Context(new AddOperation());
context.executeStrategy(10, 5); // 15
// 变化算法
context = new Context(new SubtractOperation());
context.executeStrategy(10, 5); // 5
```

## 总结
使用策略模式后，减少了各种算法类和使用算法类之间的耦合。  
并且因为继承`Strategy`类后，有助于获取公共方法。  
每个方法都有自己的类，还简化了单元测试。