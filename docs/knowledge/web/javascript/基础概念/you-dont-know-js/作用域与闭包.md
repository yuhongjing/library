---
title: 作用域与闭包
---

# 作用域与闭包

章节目录：

* [什么是作用域?](#什么是作用域？)
* [词法作用域](#词法作用域)
* [函数与块儿作用域](#函数与块儿作用域)
* 提升
* 作用域闭包
* 附录

## 什么是作用域？

所有语言的最基础的模型之一就是在变量中存储值，并在稍后取出或修改这些值的能力。事实上，在变量中存储值和取出值的能力，给程序赋予了`状态`。

但程序中纳入变量，引出了几个问题：变量`存储`在哪里？程序需要变量的时候，如何找到它们？

回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。这组规则称为：`作用域`。

### 编译器理论

传统编译型语言处理中，在被执行之前通常会经历三个步骤，大致被称为`编译`。

1. 分词/词法分析

   将一串字符打断成有意义的片段，称为`token`(记号)。

::: warning 注意

分词与词法分析的区别是比较微妙的，其核心在于这些`token`是以`无状态`或`有状态`的方式被识别。

简而言之，如果分词器去调用有状态的的解析规则来弄清`a`是否应当被考虑为一个不同的`token`，还是只是其他`token`的一部分，那么这就是**词法解析**。

:::

2. 解析

   将一个`token`流(数组)转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为`抽象语法树`(AST——Abstract Syntax Tree)

3. 代码生成

   将抽象语法树转换为可执行的代码。这一部分根据语言，目标平台等因素有较大不同。可以简单理解为，将抽象语法树转换为机器指令。

和大多数其他语言的编译器一样，JavaScript引擎要比这区区三步复杂太多了。例如，在解析和代码生成的处理中，一定会存在优化执行效率的步骤，包括压缩冗余元素等。

JavaScript引擎没有（像其他语言的编译器那样）大把的时间去优化，因为JavaScript的编译和其他语言不同，不是提前发生在一个构建的步骤中。

在许多情况下，JavaScript的编译发生在代码被执行前的仅仅几微秒之内（或更少），为了确保最快的性能，JS引擎将使用所有的招数（比如JIT，它可以懒编译甚至是热编译等等）。

为了简单起见，我们可以说，任何JavaScript代码段在它执行之前（通常是`刚好`在它执行之前）都必须被编译。

### 理解作用域

* 引擎：负责从始至终的编译和执行JS程序
* 编译器：引擎的辅助，处理代码解析和生成代码的重活
* 作用域：引擎的辅助，收集并维护一张所有被声明的标识符列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

#### 编译器术语

* LHS：Left-hand Side

  LHS寻找变量容器本身，以便它可以赋值。简单理解为：`取得它的源`。

* RHS：Right-hand Side

  RHS寻找值。简单理解为：`去取...的值`。

### 嵌套作用域

`作用域`是通过标识符名称查询变量的一组规则。但是，通常`作用域`不仅仅是单一的。

代码块或函数可以被嵌套在另一个代码块或函数中，作用域也会被嵌套在其他作用域中。所以，如果在直接作用域中找不到一个变量的话，引擎就会咨询下一个外层作用域，直到全局作用域为止。

遍历嵌套`作用域`的简单规则：引擎从当前执行的作用域开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，无论是否找到了变量，都会停止继续查找。

### 错误

为什么区别LHS和RHS那么重要？因为两种类型的查询行为不同。

* RHS查询，如果在作用域中找不到，引擎会抛出`ReferenceError`错误。

* LHS查询，如果在作用域中找不到，非Strict模式，会在全局作用域中自动创建这个值；Strict模式下会抛出`ReferenceError`错误。

现在，如果一个RHS查询的变量被找到了，你尝试做一些这个值不能做到的事情，比如将非函数值作为函数运行或者引用`null`、`undefined`值的属性，那么引擎就会抛出`TypeError`错误。

总结下来就是：`ReferenceError`是关于`作用域`解析失败的，而`TypeError`暗示`作用域`解析成功了，但是试图对结果进行非法操作。

## 词法作用域

作用域的工作方式有两种占统治地位的模型。

* 词法作用域
* 动态作用域

JavaScript采用的作用域模型为**词法作用域**。

### 词法分析时

标准语言编译器的第一个传统步骤为词法分析（也就是分词），是检查一串源代码字符并给`token`赋予语法含义作为某种有状态解析的输出。

词法作用域是在词法分析时被定义的作用域。换句话说，词法作用域是基于开发者在写程序时，定义变量和作用域的块儿时所决定的。

::: warning 注意

虽然JS可以通过某些方法骗过词法作用域，从而在词法分析器处理过后改变它，但这些方法都是不优雅的。

公认的最佳实践是，词法作用域只依靠词法，编写时就应该可以确定它。

:::

#### 查询

当查询一个标识符时，**一旦找到第一个匹配，作用域查询就停止了**。因此内层作用域的标识符会**遮蔽**(shadowing)外层作用域的标识符。

词法作用域查询只会处理**头等标识符**，例如`foo.bar.baz`，词法作用域只会查询`foo`标识符，一旦定位这个变量，`对象属性访问规则`将会分别接管`bar`和`baz`属性的解析。

### 欺骗词法作用域

词法作用域是编写时决定的，这也是最佳的实践。那么有没有可能在运行时『修改』（欺骗）词法作用域呢？

JS有两种这样的机制，目前公认其存在效率低下，实现不优雅，阅读难度提升等问题。当然最主要的问题就是：**欺骗词法作用域会导致低下的性能**。

* eval
* with

为什么欺骗词法作用域会导致性能下降呢？因为JS引擎在编译阶段期间进行了许多性能优化工作，其中的一些优化原理都归结为实质上在进行词法解析时可以静态地分析代码并提前决定所有的变量和函数声明在什么位置，这样在执行期间就可以少花力气来解析标识符。

但如果引擎在代码中发现了`evel`或`with`，它就得假定已知的所有标识符位置可能是无效的，因为在词法分析时它不可能知道你将会传递怎么样的代码来修改词法作用域。

因此只要`evel`或`with`出现，JS引擎做的所有优化都将没有意义，所以**性能会下降**。

## 函数与块儿作用域