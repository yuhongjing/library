---
title: 类型与文法
---

# 类型与文法

章节目录：

* [类型](#类型)
* [值](#值)
* [原生类型](#原生类型)
* [强制转换](#强制转换)
* [文法](#文法)
* [附录](#附录)

## 类型

大多数开发者认为，动态语言没有*类型*。但是ES5.1规范是这么说的：

> 在本语言规范中的算法所操作的每一个值都有一种关联的类型。可能的值的类型就是那些在本条款中定义的类型。类型还进一步被分为ECMAScript语言类型和语言规范类型
>
> 一个ECMAScript语言类型对应ECMAScript程序员使用ECMAScript语言直接操作的值。ECMAScript语言类型有Undefined、Null、Boolean、String、Number和Object。

现在，如果你是强类型(静态类型)语言的爱好者，你可以会反对『类型』一次的用法。在那些语言中，『类型』的含义要比它在JS这里的含义丰富得多。

一个粗糙的定义：一个*类型*是一组固有的，内建的性质，对于引擎**和开发者**来说，它独一无二地标识了一个特定的值的行为，并将它与其他值区分开来。

### 类型的重要意义

抛开学术上关于定义的分歧，为什么JavaScript有或者没有*类型*那么重要？

对每一种*类型*和它的固有行为有一个正确的理解，对于理解如何正确和准确地转换两个不同类型的值来说是绝对必要的。几乎每一个被编写过的JS程序都需要以某种形式处理类型的强制转换。

对强制转换的困惑可能是JavaScript开发者所经历的最深刻的挫败感之一，它曾经总是因为如此*危险*而为人所诟病，被认为是语言设计上的缺点而应当被回避。

带着对JavaScript类型的全面理解，我们将要阐明为什么强制转换的*坏名声*是言过其实，而且是有些冤枉的——以此反转你的视角，来看清强制转换的力量和用处。但首先，我们必须更好地把握值和类型。

### 内建类型

JavaScript定义了七种内建类型：

* `null`
* `undefined`
* `boolean`
* `number`
* `string`
* `object`
* `symbol`

注意：除了`Object`，其他类型都称为『基本类型』。

`typeof`操作符可以检测给定值的类型，而且总是返回七种字符串的值的一种——令人吃惊的是，对于我们刚刚列出的七种内建类型，它没有一个恰好的一对一匹配。

```js
typeof undefined === "undefined"; // true
typeof true === "boolean"; // true
typeof 42 === "number"; // true
typeof "42" === "string"; // true
typeof {life: 42} === "object"; // true

// 在ES6中被加入
typeof Symbol() === "symbol"; // true
```

如上所示，你可以发现剔除了`null`，它是特殊的——特殊在于它与`typeof`操作符组合时有Bug。

```js
typeof null === "object"; // true
```

这个Bug已经存在20年了，应该永远不会修复了，因为有太多的web的内容依存着这个Bug的行为，修复Bug将会制造更多的Bug。

如果你想使用`null`类型来测试`null`值，你需要一个复合条件：

```js
var a = null;

(!a && typeof a === "object"); // true
```

`null`是唯一一个`falsy`，但是在`typeof`检测中返回"object"的基本类型。

那么`typeof`可以返回的第七种字符串值是什么？

```js
typeof function a(){} === "function"; // true
```

很容易让人以为JS中`function`是一种顶层的内建类型，特别是看到`typeof`操作符的这种行为时。然而，如果你阅读语言规范，你会看到它实际上是对象(object)的子类型。特别地，一个函数(function)被称为可调用对象——一个拥有`[[Call]]`内部属性、允许被调用的对象。

函数实际上是对象这一事实十分有用。最重要的是，它们可以拥有属性。例如：

```js
function a(b, c) {
  /*  */
}
```

这个函数对象拥有一个`length`属性，它被设置为函数被声明时的形式参数的数量。

```js
a.length; // 2
```

那么数组呢？它们是JS原生的，所以它们是一个特殊的类型吗？

```js
typeof [1, 2, 3] === "object"; // true
```

不，它们仅仅是对象。考虑它们最恰当的方法是，它们是对象的子类型，带有被数字索引的附加性质，并维护一个自动更新的`.length`属性。

### 值作为类型

在JavaScript中，变量没有类型——**值才有类型**。变量可以在任何时候，持有任何值。

另一种考虑JS类型的方式是，JS没有『类型强制』，也就是引擎不坚持认为一个*变量*总是持有与它开始存在时相同的*初始类型*的值。

#### `undefined` vs undeclared

当前还不拥有值的变量，实际上拥有`undefined`值。对这样的变量调用`typeof`将会返回`undefined`：

```js
var a;

typeof a; // undefined

var b = 42;
var c;

// 稍后
b = c;

typeof b; // undefined
typeof c; // undefined
```

大多数开发者考虑`undefined`这个词的方式会诱使他们认为它是"undeclared"(未声明)的同义词。然而在JS中，这两个概念十分不同。

一个`undefined`变量是在可访问的作用域中已经被声明过的，但是在*这个时刻*它里面没有任何值。相比之下，一个undeclared变量是在可访问的作用域中还没有被正式声明的。

考虑这段代码：

```js
var a;

a; // undefined
b; // ReferenceError: b is not defined
```

比较困扰的反馈`is not defined`，实际上指`is not declared`。因为`typeof`的保护机制，即使是`declared`也会返回`undefined`。

## 值

`array`、`string`和`number`是任何程序的最基础构建块，但是JavaScript在这些类型上有一些或使你惊喜或使你惊讶的独特性质。下面我们一起来看看如何正确的理解并利用它们的行为。

### Array

和其他强制类型的语言相比，JavaScript的`array`只是值的容器，而这些值可以是任何类型：`string`、`number`、`object`甚至是另一个`array`。

你不需要预先指定`array`的大小，你可以仅声明它们并加入你觉得适合的值：

```js
var a = [];

a.length; // 0

a[0] = 1;
a[1] = "2";
a[2] = [3];

a.length; // 3
```
