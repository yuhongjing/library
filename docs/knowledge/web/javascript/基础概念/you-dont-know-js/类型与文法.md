---
title: 类型与文法
---

# 类型与文法

章节目录：

* [类型](#类型)
* [值](#值)
* [原生类型](#原生类型)
* [强制转换](#强制转换)
* [文法](#文法)
* [附录](#附录)

## 类型

大多数开发者认为，动态语言没有*类型*。但是ES5.1规范是这么说的：

> 在本语言规范中的算法所操作的每一个值都有一种关联的类型。可能的值的类型就是那些在本条款中定义的类型。类型还进一步被分为ECMAScript语言类型和语言规范类型
>
> 一个ECMAScript语言类型对应ECMAScript程序员使用ECMAScript语言直接操作的值。ECMAScript语言类型有Undefined、Null、Boolean、String、Number和Object。

现在，如果你是强类型(静态类型)语言的爱好者，你可以会反对『类型』一次的用法。在那些语言中，『类型』的含义要比它在JS这里的含义丰富得多。

一个粗糙的定义：一个*类型*是一组固有的，内建的性质，对于引擎**和开发者**来说，它独一无二地标识了一个特定的值的行为，并将它与其他值区分开来。

### 类型的重要意义

抛开学术上关于定义的分歧，为什么JavaScript有或者没有*类型*那么重要？

对每一种*类型*和它的固有行为有一个正确的理解，对于理解如何正确和准确地转换两个不同类型的值来说是绝对必要的。几乎每一个被编写过的JS程序都需要以某种形式处理类型的强制转换。

对强制转换的困惑可能是JavaScript开发者所经历的最深刻的挫败感之一，它曾经总是因为如此*危险*而为人所诟病，被认为是语言设计上的缺点而应当被回避。

带着对JavaScript类型的全面理解，我们将要阐明为什么强制转换的*坏名声*是言过其实，而且是有些冤枉的——以此反转你的视角，来看清强制转换的力量和用处。但首先，我们必须更好地把握值和类型。

### 内建类型

JavaScript定义了七种内建类型：

* `null`
* `undefined`
* `boolean`
* `number`
* `string`
* `object`
* `symbol`

注意：除了`Object`，其他类型都称为『基本类型』。

`typeof`操作符可以检测给定值的类型，而且总是返回七种字符串的值的一种——令人吃惊的是，对于我们刚刚列出的七种内建类型，它没有一个恰好的一对一匹配。

```js
typeof undefined === "undefined"; // true
typeof true === "boolean"; // true
typeof 42 === "number"; // true
typeof "42" === "string"; // true
typeof {life: 42} === "object"; // true

// 在ES6中被加入
typeof Symbol() === "symbol"; // true
```

如上所示，你可以发现剔除了`null`，它是特殊的——特殊在于它与`typeof`操作符组合时有Bug。

```js
typeof null === "object"; // true
```

这个Bug已经存在20年了，应该永远不会修复了，因为有太多的web的内容依存着这个Bug的行为，修复Bug将会制造更多的Bug。

如果你想使用`null`类型来测试`null`值，你需要一个复合条件：

```js
var a = null;

(!a && typeof a === "object"); // true
```

`null`是唯一一个`falsy`，但是在`typeof`检测中返回"object"的基本类型。

那么`typeof`可以返回的第七种字符串值是什么？

```js
typeof function a(){} === "function"; // true
```

很容易让人以为JS中`function`是一种顶层的内建类型，特别是看到`typeof`操作符的这种行为时。然而，如果你阅读语言规范，你会看到它实际上是对象(object)的子类型。特别地，一个函数(function)被称为可调用对象——一个拥有`[[Call]]`内部属性、允许被调用的对象。

函数实际上是对象这一事实十分有用。最重要的是，它们可以拥有属性。例如：

```js
function a(b, c) {
  /*  */
}
```

这个函数对象拥有一个`length`属性，它被设置为函数被声明时的形式参数的数量。

```js
a.length; // 2
```

那么数组呢？它们是JS原生的，所以它们是一个特殊的类型吗？

```js
typeof [1, 2, 3] === "object"; // true
```

不，它们仅仅是对象。考虑它们最恰当的方法是，它们是对象的子类型，带有被数字索引的附加性质，并维护一个自动更新的`.length`属性。

### 值作为类型

在JavaScript中，变量没有类型——**值才有类型**。变量可以在任何时候，持有任何值。

另一种考虑JS类型的方式是，JS没有『类型强制』，也就是引擎不坚持认为一个*变量*总是持有与它开始存在时相同的*初始类型*的值。

#### `undefined` vs undeclared

当前还不拥有值的变量，实际上拥有`undefined`值。对这样的变量调用`typeof`将会返回`undefined`：

```js
var a;

typeof a; // undefined

var b = 42;
var c;

// 稍后
b = c;

typeof b; // undefined
typeof c; // undefined
```

大多数开发者考虑`undefined`这个词的方式会诱使他们认为它是"undeclared"(未声明)的同义词。然而在JS中，这两个概念十分不同。

一个`undefined`变量是在可访问的作用域中已经被声明过的，但是在*这个时刻*它里面没有任何值。相比之下，一个undeclared变量是在可访问的作用域中还没有被正式声明的。

考虑这段代码：

```js
var a;

a; // undefined
b; // ReferenceError: b is not defined
```

比较困扰的反馈`is not defined`，实际上指`is not declared`。因为`typeof`的保护机制，即使是`declared`也会返回`undefined`。

## 值

`array`、`string`和`number`是任何程序的最基础构建块，但是JavaScript在这些类型上有一些或使你惊喜或使你惊讶的独特性质。下面我们一起来看看如何正确的理解并利用它们的行为。

### Array

和其他强制类型的语言相比，JavaScript的`array`只是值的容器，而这些值可以是任何类型：`string`、`number`、`object`甚至是另一个`array`。

你不需要预先指定`array`的大小，你可以仅声明它们并加入你觉得适合的值：

```js
var a = [];

a.length; // 0

a[0] = 1;
a[1] = "2";
a[2] = [3];

a.length; // 3
```

::: warning 警告

`array`值使用`delete`仅会删除值，但是不会更新`length`属性。

:::

小心创建『稀散』的`array`(留下或创建空的/丢失的值槽)：

```js
var a = [ ];

a[0] = 1;
// 这里没有设置值槽a[1]
a[2] = [3];

a[1]; // undefined

a.length; // 3
```

虽然它可以工作，但是留下的『空值槽』会导致令人困惑的行为。虽然这样的值槽看起来拥有`undefined`值，但是它不会像明确设置(`a[1] = undefined`)的值槽那样动作。

`array`是被数字索引的，但微妙的是它们也是对象，可以在它们上面添加`string`键/属性(但属性不会计算在`length`中)：

```js
var a = [ ];

a[0] = 1;
a["footer"] = 2;

a.length; // 1
a["footer"]; // 2
a.foobar; // 2
```

然而，一个需要小心的坑是，如果一个可以被强制转换为10进制`number`的`string`值被用作键的话，它会认为你想使用`number`索引而不是`string`键！

```js
var a = [ ];

a["13"] = 42;

a.length; // 14
```

一般来说，向`array`添加`string`键/属性不是一个好主意。最好使用`object`来持有键/属性形式的值，而`array`专用于严格地数字索引的值。

#### 类Array

有时你需要将一个类`array`值(一个数字索引的值集合)转换为一个真正的`array`，这样就可以调用数组的工具函数。

举个例子，DOM查询操作会返回DOM元素的列表、函数参数`arguments`对象等。

一个常见的转换方法是使用slice工具：

```js
function foo() {
  var arr = Array.prototype.slice.call(arguments);
  arr.push("bam");
  console.log(arr);
}

foo("bar", "baz"); // ["bar", "baz", "bam"]
```

如果slice没有其他参数，会默认使它具有复制这个`array`的效果。

在ES6中，可以通过`Array.from()`执行相同的任务：

```js
var arr = Array.from(arguments);
```

注意：`Array.from`拥有其他几种强大的能力，之后会涵盖它的细节。

### String

一个很常见的想法是，`string`实质上是字符的`array`。虽然内部的实现可能是也可能不是`array`，但重要的是理解JavaScript的`string`与字符的`array`确实不一样，它们的相似性几乎只是表面上的。

举个例子，我们考虑如下两个值：

```js
var a = "foo";
var b = ["f", "o", "o"];
```

String确实与`array`有很肤浅的相似性--也就是上面说的，类`array`--举例来说，它们都有`length`属性，一个`indexOf`方法和一个`concat`方法。

```js
a.length; // 3
b.length; // 3

a.indexOf("o"); // 1
b.indexOf("o"); // 1

var c = a.concat("bar"); // foobar
var d = b.concat(["b", "a", "r"]); // ["f","o","o","b","a","r"]

a === c; // false
b === d; // false

a; // "foo"
b; // ["f","o","o"]
```

那么，它们基本上都仅仅是"字符的数组"，对吧？**不确切**：

```js
a[1] = "0";
b[1] = "0";

a; // foo
b; // ["f","o","o"]
```

JavaScript的`string`是不可变的，而`array`是可变的。另外，在JavaScript中用位置访问字符的`a[1]`形式不总是广泛合法的，例如低版本的IE就不支持这种语法，而需要使用`a.charAt(1)`。

`string`不可变性的进一步后果是，`string`上没有一个方法是可以原地修改它的内容的，而是创建并返回一个新的`string`。与之相对的是，许多改变`array`内容的方法实际上是原地修改的。

```js
c = a.toUpperCase();
a === c; // false
a; // foo
c; // FOO

b.push("!");
b; // ["f","O","o","!"]
```

另外，许多`array`方法在处理`string`时非常有用，虽然这些方法不属于`string`，但是我们可以针对我们的`string`"借用"非变化的`array`方法：

```js
a.join; // undefined
a.map; // undefined

var c = Array.prototype.join.call(a, "-");
var d = Array.prototype.map.call(a, function(v) {
  return v.toUpperCase() + '.';
}).join("");

c; // f-o-o
d; // F.O.O.
```

让我们来看另一个例子：翻转一个`string`。`array`拥有一个原地的`reserver`修改器方法，但是`string`没有：

```js
a.reverse; // undefined

b.reverse(); // ["!","o","O","f"]
b; // ["!","o","O","f"]
```

不幸的是，这种"借用"`array`修改器不起作用，因为`string`是不可变的吗，因此它不能被原地修改：

```js
Array.prototype.reverse.call(a);
// 仍然返回一个"foo"的String对象包装器
```

另一种迂回的做法是，将`string`转换为一个`array`，实施我们想做的操作，然后将它转回`string`。

```js
var c = a.split("").reverse().join("");

c; // oof
```

### Number

JavaScript只有一种数字类型：`number`。这种类型包含"整数"值和小数值。我说"整数"时加了引号，因为JS的一个长久以来为人诟病的原因是和其他语言不同，JS没有真正的整数。这可能在未来某个时候会改变，但是目前，我们只有`number`可用。

所以，在JS中，一个"整数"只是一个没有小数部分的小数值。也就是说，`42.0`和`42`一样是"整数"。

像大多数现代计算机语言以及几乎所有的脚本语言一样，JavaScript的`number`的实现基于"IEEE 754"标准，通常被称为"浮点"。JavaScript明确地使用了这个标准的"双精度"(也就是64位二进制)格式。

#### 数字的语法

在JavaScript中字面数字一般用十进制小数表达。例如：

```js
var a = 42;
var b = 42.3;
```

小数的整数部分如果是`0`，是可选的：

```js
var a = 0.42;
var b = .42;
```

相似地，一个小数在`.`之后的小数部分如果是`0`，是可选的：

```js
var a = 42.0;
var b = 42.; // 尽管它是合法的，但是会让阅读者感到困惑，因此尽量不要这样书写。
```

默认情况下，大多数`number`将会以十进制小数的形式输出，并去掉末尾小数的部分的`0`。所以：

```js
var a = 42.300;
var b = 42.0;

a; // 42.3
b; // 42
```

非常大或非常小的`number`将默认以指数形式输出，与`toExponential`方法的输出一样，比如：

```js
var a = 5E10;
a; // 50000000000
a.toExponential(); // 5e+10

var b = a * a;
b; // 2.5e+21

var c = 1 / a;
c; // 2e-11
```

因为`number`值可以用`Number`对象包装器封装，所以`number`值可以访问内建在`Number.prototype`的方法，举个例子，`toFixed`方法允许你指定一个值在被表示时，带有多少位小数：

```js
var a = 42.59;

a.toFixed(0); // 43
a.toFixed(1); // 42.6
a.toFixed(2); // 42.59
a.toFixed(3); // 42.590
a.toFixed(4); // 42.5900
```

注意，这里返回的是`number`的`string`表现形式，而且会补0.

`toPrecision`很相似，但它指定的是有多少*有效数字*用来表示这个值：

```js
var a = 42.59;

a.toPrecision(1); // 4e+1
a.toPrecision(2); // 43
a.toPrecision(3); // 42.6
a.toPrecision(4); // 42.59
a.toPrecision(5); // 42.590
a.toPrecision(6); // 42.5900
```

你可以直接在`number`上访问这些方法，但你得小心`.`操作符。因为`.`是一个合法数字字符，如果有可能的话，它会首先被翻译为`number`字面的一部分，而不是被翻译为属性访问操作符。

```js
// 不合法的语法：
42.toFixed(3); // SyntaxError

// 合法：
(42).toFixed(3); // 42.000
0.42.toFixed(3); // 0.420
42..toFixed(3); // 42.000
```

`number`还可以使用科学计数法的形式指定，这在表示很大的`number`时很常见，比如：

```js
var onethousand = 1E3; // 代表 1 * 10 ^ 3
var onemilliononehundredthousand = 1.1E6; // 代表 1.1 * 10 ^ 6
```

`number`字面量还可以使用其他进制表达，比如二进制，八进制和十六进制。

```js
Oxf3; // 十六进制 243
OXf3; // 同上

0363; // 八进制 243
```

#### 小数值

使用二进制浮点数的最出名的副作用是（对所有使用IEEE 754语言都成立的）：

```js
0.1 + 0.2 === 0.3; // false
```

从数学意义上，我们知道这个等式应当成立，但为什么它是`false`呢？

简单地说，`0.1`和`0.2`的二进制表示形式是不精确的，所以它们相加时，结果不是精确地`0.3`。而是**非常**接近的值：`0.30000000000000004`。

现在的问题是，如果一些`number`不能被*信任*为精确的，这不是意味着我们根本不能使用`number`吗？**当然不是**。

在一些应用程序中你需要多加小心，特别是在对付小数的时候。还有许多应用程序只处理整数，而且最大只处理到几百万到几万亿。这些应用程序使用JS中的数字操作是**非常安全**的。

要是我们*确实*需要比较两个`number`，就像是`0.1 + 0.2`与`0.3`，而且知道这个简单的相等测试会失败呢？

可以接受的最常见的做法是使用一个很小的"错误舍入"值作为比较的*容差*。这个很小的值经常被称为"机械极小值(machine epsilon)"，对于JavaScript来说这种`number`通常为`2^-52`。

在ES6中，使用这个容差值预定义了`Number.EPSILON`，所以你将会使用它，你也可以在ES6中安全的填补这个定义：

```js
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, -52);
}
```

我们可以使用这个`Number.EPSILON`来比较两个`number`的"等价性"(带有错误舍入的容差)：

```js
function numbersCloseEnoughToEqual(n1, n2) {
  return Math.abs(n1 - n2) < Number.EPSILON;
}

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual(a, b); // true
numbersCloseEnoughToEqual(0.0000001, 0.0000002);	// false
```

可以被表示的最大的浮点值大概是`1.798e+308`，它为你预定义为`Number.MAX_VALUE`，在极小的一端，`Number.MIN_VALUE`大概是`5e-324`，它不是负数但是非常接近于0！

#### 安全整数范围

由于`number`的表示方式，对完全是`number`的整数而言有一个安全的值的范围，而且它要比`Number.MAX_VALUE`小得多。

可以『安全地』被表示的最大整数是`2^53 - 1`，也就是`9007199254740991`，刚好9万亿左右，还是挺大的。

在ES6中这个值实际上是自动预定义的，它是`Number.MAX_SAFE_INTEGER`。意料之中的是，还有一个最小值`-9007199254740991`，它在ES6中定义为`Number.MIN_SAFE_INTEGER`。

JS程序面临处理这样大的数字的主要情况是，处理数据库中的64位ID等等。64位数字不能使用`number`类型准确表达，所以在JavaScript中必须使用`string`表现形式存储(和传递)。

#### 测试整数

测试一个值是否是整数，你可以使用ES6定义的`Number.isInteger`：

```js
Number.isInteger(42); // true
Number.isInteger(42.000); // true
Number.isInteger(42.3); // false
```

为ES6前填补`Number.isInteger`：

```js
if (!Number.isInteger) {
  Number.isInteger = function (num) {
    return typeof num == "number" && num % 1 == 0;
  };
}
```

要测试一个值是否为*安全整数*，使用ES6定义的`Number.isSafeInteger`：

```js
Number.isSafeInteger(Number.MAX_SAFE_INTEGER); // true
Number.isSafeInteger(Math.pow(2, 53)); // false
Number.isSafeInteger(Math.pow(2, 53) - 1); // true
```

为ES6前填补`Number.isSafeInteger`：

```js
if (!Number.isSafeInteger) {
  Number.isSafeInteger = function (num) {
    return Number.isIntefer(num)
      && Math.abs(num) <= Number.MAX_SAFE_INTEGER;
  };
}
```

#### 32位(有符号)整数

虽然整数可以安全地最大达到约九万亿，但有一些数字操作是仅仅为32位`number`定义的。

要强制`a`中的`number`值是32位有符号整数，使用`a|0`，这可以工作是因为`|`位操作符仅仅对32位值起作用。而且，和0进行"或"的位操作实质上是什么也不做。

### 特殊值

在各种类型中散布着一些特殊值，需要开发者*警惕*并正确使用。

#### 不是值的值

对于`undefined`类型来说，有且仅有一个值：`undefined`。对于`null`类型来说，有且仅有一个值：`null`。所以对它们而言，这些文字既是它们的类型也是它们的值。

`undefined`和`null`作为"空"值或者"没有"值，经常被认为是可以互换的。另一些开发者偏好于使用微妙的区别将它们区分开。举例来说：

* `null`是一个空值。
* `undefined`是一个丢失的值。

或者：

* `undefined`还没有值。
* `null`曾经有过值但现在没有。

不管你选择如何"定义"和使用这两个值，`null`是一个特殊的关键字，不是一个标识符，因此你不能将它作为一个变量对待来给它赋值。然而，`undefined`是一个标识符。

#### Undefined

在非`strict`模式下，给在全局上提供的`undefined`标识符赋值是可能的：

```js
function foo() {
  undefined = 2; // 这。。。这。。
}

foo();
```

```js
function foo() {
  "use strict";
  undefined = 2; // TypeError!
}

foo();
```

但是，在非`strict`模式和`strict`模式下，你可以创建名为`undefiend`的局部变量。

```js
function foo() {
  "use strict";
  var undefined = 2;
  console.log(undefined); // 2
}

foo();
```

**朋友永远不让朋友覆盖`undefined`**。

#### void操作符

另一个能得到`undefined`值的方法是`void`操作符。

表达式`void __`会"躲开"任何值，所以这个表达式的结果总是`undefined`。它不会修改任何已经存在的值；只是确保不会有值从操作符表达式中返回来。

```js
var a = 42;

console.log(void a, a); // undefined 42
```

从惯例上讲，要通过使用`void`来独立表现值`undefined`，你可以使用`void 0`。实际上`void 0`、`void 1`和`undefined`没有区别。

但是在几种其他情况下`void`操作符可以十分有用：如果你需要确保一个表达式没有结果值(即便它有副作用)。举个例子：

```js
function doSomething() {
  // 注意：APP.ready 是由我们的应用程序提供的
  if (!APP.ready) {
    // 稍后再试一次
    return void setTimeout(doSomething, 100);
  }

  var result;

  // 做一些其他事情
  return result;
}

// 我们能立即执行吗？
if (doSomething()) {
  // 马上处理其他任务
}
```

这里，`setTimeout`函数返回一个数字值，但是我们想`void`它，这样函数就只会返回`undefined`了。

许多开发者宁愿将这些动作分开，功能相同但可以不使用`void`操作符：

```js
if (!APP.ready) {
  // 稍后再试一次
  setTimeout(doSomething, 100);
  return;
}
```

#### 特殊的数字

`number`类型包含几种特殊值。我们将会仔细考察每一种。

##### 不是数字的数字

如果你不使用同为`number`的两个操作数进行任何算数操作，那么操作的结果将失败而产生一个不合法的`number`，这种情况下就会获得`NaN`值。

`NaN`在字面上代表"不是一个`number`(Not a Number)"，但是正如我们即将看到的，这种文字描述十分失败而且容易误导人。将`NaN`考虑为"不合法数字"，"失败的数字"甚至是"坏掉的数字"都要比"不是一个数字"准确得多。举例来说：

```js
var a = 2 / "foo"; // NaN

typeof a === "number"; // true
```

换句话说："'不是一个数字'的类型是'数字'"。。。。。。。。。

`NaN`是一种"哨兵值"(一个被赋予了特殊意义的普通的值)，它代表`number`集合内的一种特殊的错误情况。这种错误情况实质上是："我试着进行数学操作但是失败了，而这就是失败的`number`结果"。

那么，如果你有一个值存在某个变量中，而且你想要测试它是否是这个特殊的失败数字`NaN`，你也许认为可以直接与`NaN`本身比较，但事实不可以。

```js
var a = 2 / "foo";

a == NaN; // false
a === NaN; // false
```

`NaN`是一个非常特殊的值，它是唯一一个不具有反射性的值，所以`NaN !== NaN`。

那我们如何去测试它呢？

```js
var a = 2 / "foo";

isNaN(a); // true
```

够简单吧，通过全局`isNaN`内建工具，来告诉它是否是`NaN`，问题解决了！

别高兴得太早。

`isNaN`工具有一个重大缺陷。它的工作原理是——测试这个传进来的东西是否不是一个`number`或者是一个`number`。但这不准确。

```js
var a = 2 / "foo";
var b = "foo";

a; // NaN
b; // "foo"

window.isNaN(a); // true
window.isNaN(b); // true
```

很明显，`"foo"`根本*不是一个`number`*，但它也不是`NaN`值！这个Bug从最开始的时候就存在于JS中了。

在ES6中，终于找到了替代的工具：`Number.isNaN`，有一个简单的填补支持ES6前。

```js
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return n !== n;
  };
}
```

怪吧？但是好用！

##### 无穷

来自于像C这样的传统编译型语言的开发者，可能习惯于看到编译器错误或者是运行时异常，比如对这样一个操作给出的"除数为0"：

```js
var a = 1 / 0;
```

然而在JS中，这个操作是明确定义的，而且它的结果是值`Infinity`(也就是`Number.POSITIVE_INFINITY)。意料之中的是：

```js
var a = 1 / 0; // Infinity
var b = -1 / 0; // -Infinity
```

如你所见，`-Infinity`是从任一个被除数为负的除0操作得来的。

##### 零

虽然这可能使有数学头脑的读者困惑，但JavaScript拥有`-0`和`+0`。在我们讲解为什么`-0`存在之前，我们应该考察JS如何处理它，因为它可能十分令人困惑。

除了使用字面量`-0`指定，负的零还可以从特定的数学操作中得出。比如：

```js
var a = 0 / -3; // -0
var b = 0 * -3; // -0
```

加法和减法无法得出负零。

在开发者控制台中考察一个负的零，经常显示为`-0`，然而直到最近这才是一个常见情况，所以一些你可能遇到的老版本浏览器也许依然将它报告为`0`。

但是根据语言规范，如果你试着将一个负零转换为字符串，它将总会被报告为`"0"`。

```js
var a = 0 / -3;

// 至少(有些浏览器)控制台是对的
a; // -0

// 但是语言规范坚持要向你撒谎
a.toString(); // "0"
a + ""； // "0"
String(a); // "0"

// 奇怪的是，就连JSON也加入了骗局之中
JSON.stringify(a); // "0"
```

有趣的是，反向操作(从`string`到`number`)不会撒谎：

```js
+"-0"; // -0
Number("-0"); // -0
JSON.parse("-0"); // -0
```

除了一个负零的字符串化会欺骗性地隐藏它实际的值外，比较操作符也被设定为(有意地)要说慌。

```js
var a = 0;
var b = 0 / -3;

a == b; // true
-0 == 0; // true

a === b; // true
-0 === 0; // true

0 > -0; // false
a > b; // false
```

很明显，如果你想在你的代码中区分`-0`和`0`，你就不能仅依靠开发者控制台的输出，你必须更聪明一些;

```js
function isNegZero(n) {
  n = Number(n);
  return (n === 0) && (1 / n === -Infinity);
}

isNegZero(-0); // true
isNegZero(0 / -3); // true
isNegZero(0); // false
```

那么，除了学院派的细节以外，我们为什么需要一个负零呢？

在一些应用程序中，开发者使用值的大小来表示一部分信息(比如动画中每一帧的速度)，而这个`number`的符号来表示另一部分信息(比如移动的方向)。在这些应用程序中，举例来说，如果一个变量的值变成了0，而它丢失了符号，那么你就丢失了它是从哪个方向移动到0的信息。保留0的符号避免了潜在的意外信息丢失。

#### 特殊等价

正如我们上面看到的，当使用等价性比较时，值`NaN`和值`-0`拥有特殊的行为。`NaN`永远不会和自己相等，所以你不得不使用ES6的`Number.isNaN`。相似地，`-0`撒谎并假装它和`+0`相等，所以你不得不使用上面`isNegZero`工具来比较。

在ES6中，有一个新工具可以测试两个值的绝对等价性，它称为`Object.is`：

```js
var a = 2 / "foo";
var b = -3 * 0;

Object.is(a, NaN); // true
Object.is(b, -0); // true

Object.is(b, 0); //false
```

对于ES6前的填补：

```js
if (!Object.is) {
  Object.is = function (v1, v2) {
    // 测试 -0
    if (v1 === 0 && v2 === 0) {
      return 1 / v1 === 1 / v2;
    }
    // 测试 NaN
    if (v1 !== v1) {
      return v2 !== v2;
    }
    // 其他情况
    return v1 === v2;
  };
}
```

`Object.is`主要是处理这些特殊的等价情况。

### 值与引用

在其他许多语言中，根据你使用的语法，值可以通过值拷贝，也可以通过引用拷贝来赋予/传递。

比如，在C++中如果你想要把一个`number`变量传递进一个函数，并使这个变量的值被更新，你可以用`int& myNum`这样的东西来声明函数参数，当你传入一个变量`x`时，`myNum`将是一个**指向`x`的引用**；引用就像一个特殊形式的指针，你得到的是一个指向另一个变量的指针(像别名alias)。如果你没有声明一个引用参数，被传入的值将*总是*被拷贝的，就算它使一个复杂的对象。

在JavaScript中，没有指针，并且引用的工作方式有一点儿不同。你不能拥有从一个JS变量到另一个JS变量的引用。

JS中的引用指向一个(共享的)**值**，所以即便你有十个不同的引用，它们仍都共享同一个值。

在JavaScript中，没有语法上的提示可以控制值和引用的赋值/传递。取而代之的是，值的*类型*用来*唯一*控制值是通过值拷贝，还是引用拷贝来赋予。

让我们来展示一下：

```js
var a = 2;
var b = a; // b总是a中的值的拷贝
b++;
a; // 2
b; // 3

var c = [1, 2, 3];
var d = c; // d是共享值[1, 2, 3]的引用
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]
```

简单值(也叫基本标量)*总是*通过值拷贝来赋予/传递：`null`、`undefined`、`string`、`number`、`boolean`以及ES6的`symbol`。

复合值(`object`和`function`)*总是*在赋值或传递时创建一个引用的拷贝。

引用指向的是值本身而不是变量，你不能使用一个引用来改变另一个引用所指向的值：

```js
var a = [1,2,3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]

// 稍后
b = [4,5,6];
a; // [1,2,3]
b; // [4,5,6]
```

当我们做赋值操作`b = [4, 5, 6]`时，是绝对不会影响到`a`指向的位置。

这样的困惑常见于函数参数：

```js
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  // 稍后 ---- 这里容易混淆，因为赋值了，导致引用断掉了
  x = [4,5,6];
  x.push(7);
  x; // [4,5,6,7]
}

var a = [1,2,3];

foo(a);

a; // [1,2,3,4] 不是 [4,5,6,7]
```

引用十分强大，但有时候它们碍你的事儿，而有事你会在它们不存在时需要它们。你唯一可以用来控制引用与值拷贝的东西是值本身的类型，所以你必须通过你选用的值的类型来间接地影响赋值/传递行为。

## 原生类型

在第一和第二章中，我们几次提到了各种内建类型，通常称为"原生类型"，比如`String`和`Number`。现在让我们来仔细检视它们。

这是最常用的原生类型的一览：

* `String()`
* `Number()`
* `Boolean()`
* `Array()`
* `Object()`
* `Function()`
* `RegExp()`
* `Date()`
* `Error()`
* `Symbol()`

如你所见，这些原生类型实际上是内建函数。

如果你熟悉Java语言，那么JavaScript的`String()`看起来就像是创建字符串值的`String`构造器。所以，你很快就会观察到你可以做这样的事情：

```js
var s = new String("Hello World!");

console.log(s.toString()); // "Hello World!"
```

这些原生类型的每一种确实可以被用作一个原生类型的构造器。但是被构建的东西可能与你想象的不同：

```js
var a = new String("abc");

typeof a; // "object" ... 不是 "String"

a instanceof String; // true

Object.prototype.toString.call(a); // "[object String]"
```

创建值的构造器形式(`new String("abc")`)的结果是一个基本类型值(`"abc"`)的包装器对象。

重要的是，`typeof`显示这些对象不是它们自己的特殊*类型*，而是`object`类型的子类型。

这个包装器对象可以被进一步观察，像这样：

```js
console.log(a);
```

这个语句的输出会根据你使用的浏览器变化，开发者控制台可以自由选择它认为合适的方式来序列化对象。

### 内部[[Class]]

