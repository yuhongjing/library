---
title: 类型与文法
---

# 类型与文法

章节目录：

* [类型](#类型)
* [值](#值)
* [原生类型](#原生类型)
* [强制转换](#强制转换)
* [文法](#文法)
* [附录](#附录)

## 类型

大多数开发者认为，动态语言没有*类型*。但是ES5.1规范是这么说的：

> 在本语言规范中的算法所操作的每一个值都有一种关联的类型。可能的值的类型就是那些在本条款中定义的类型。类型还进一步被分为ECMAScript语言类型和语言规范类型
>
> 一个ECMAScript语言类型对应ECMAScript程序员使用ECMAScript语言直接操作的值。ECMAScript语言类型有Undefined、Null、Boolean、String、Number和Object。

现在，如果你是强类型(静态类型)语言的爱好者，你可以会反对『类型』一次的用法。在那些语言中，『类型』的含义要比它在JS这里的含义丰富得多。

一个粗糙的定义：一个*类型*是一组固有的，内建的性质，对于引擎**和开发者**来说，它独一无二地标识了一个特定的值的行为，并将它与其他值区分开来。

### 类型的重要意义

抛开学术上关于定义的分歧，为什么JavaScript有或者没有*类型*那么重要？

对每一种*类型*和它的固有行为有一个正确的理解，对于理解如何正确和准确地转换两个不同类型的值来说是绝对必要的。几乎每一个被编写过的JS程序都需要以某种形式处理类型的强制转换。

对强制转换的困惑可能是JavaScript开发者所经历的最深刻的挫败感之一，它曾经总是因为如此*危险*而为人所诟病，被认为是语言设计上的缺点而应当被回避。

带着对JavaScript类型的全面理解，我们将要阐明为什么强制转换的*坏名声*是言过其实，而且是有些冤枉的——以此反转你的视角，来看清强制转换的力量和用处。但首先，我们必须更好地把握值和类型。

### 内建类型

JavaScript定义了七种内建类型：

* `null`
* `undefined`
* `boolean`
* `number`
* `string`
* `object`
* `symbol`

注意：除了`Object`，其他类型都称为『基本类型』。

`typeof`操作符可以检测给定值的类型，而且总是返回七种字符串的值的一种——令人吃惊的是，对于我们刚刚列出的七种内建类型，它没有一个恰好的一对一匹配。

```js
typeof undefined === "undefined"; // true
typeof true === "boolean"; // true
typeof 42 === "number"; // true
typeof "42" === "string"; // true
typeof {life: 42} === "object"; // true

// 在ES6中被加入
typeof Symbol() === "symbol"; // true
```

如上所示，你可以发现剔除了`null`，它是特殊的——特殊在于它与`typeof`操作符组合时有Bug。

```js
typeof null === "object"; // true
```

这个Bug已经存在20年了，应该永远不会修复了，因为有太多的web的内容依存着这个Bug的行为，修复Bug将会制造更多的Bug。

如果你想使用`null`类型来测试`null`值，你需要一个复合条件：

```js
var a = null;

(!a && typeof a === "object"); // true
```

`null`是唯一一个`falsy`，但是在`typeof`检测中返回"object"的基本类型。

那么`typeof`可以返回的第七种字符串值是什么？

```js
typeof function a(){} === "function"; // true
```

很容易让人以为JS中`function`是一种顶层的内建类型，特别是看到`typeof`操作符的这种行为时。然而，如果你阅读语言规范，你会看到它实际上是对象(object)的子类型。特别地，一个函数(function)被称为可调用对象——一个拥有`[[Call]]`内部属性、允许被调用的对象。

函数实际上是对象这一事实十分有用。最重要的是，它们可以拥有属性。例如：

```js
function a(b, c) {
  /*  */
}
```

这个函数对象拥有一个`length`属性，它被设置为函数被声明时的形式参数的数量。

```js
a.length; // 2
```

那么数组呢？它们是JS原生的，所以它们是一个特殊的类型吗？

```js
typeof [1, 2, 3] === "object"; // true
```

不，它们仅仅是对象。考虑它们最恰当的方法是，它们是对象的子类型，带有被数字索引的附加性质，并维护一个自动更新的`.length`属性。

### 值作为类型

