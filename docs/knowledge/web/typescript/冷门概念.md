---
title: TypeScript冷门概念
---

# TypeScript冷门概念

## 基础概念

### unknown

#### 用于断言

```typescript
const num: number = 10;
(num as unknown as string).split(''); // 这里和any一样完全可以通过静态检查
```

#### 用于类型收窄

使用any类型，相当于直接放弃类型检查

```typescript
function test(input: unknown): number {
 if (Array.isArray(input)) {
   return input.length; // 通过: 这个代码块中，类型守卫已经将input识别为array类型
 }
  return input.length; // Error: 这里的input还是unknown类型，静态检测报错。如果入参用any，则会放弃检查直接成功，带来报错风险
}
```

### void与undefined

void不在意返回类型值

```typescript
function invokeCallback(callback: () => void) {} // 声明callback的返回值为void

invokeCallback(() => 1); // 通过：这里的callback函数返回值是number类型
invokeCallback(() => 'foo'); // 通过：这里的callback函数返回值是string类型
```

undefined

```typescript
function invokeCallback(callback: () => undefined) {} // callback的返回值为undefined

invokeCallback(() => 1); // Error：Type 'number' is not assignable to type 'undefined'
invokeCallback(() => 'foo'); // Error：Type 'string' is not assignable to type 'undefined'
```

### never

无法正常返回结束的类型

```typescript
function foo(): never { throw new Error('error message') } // throw error 返回值是never
function foo(): never { while(true) } // 死循环无法退出

type human  = 'boy' & 'girl'; // 这两个类型不可能相交，因此human为never类型

// **********
// 任何类型联合never都会是原来的类型
// **********
type language = 'ts' | never; // language的类型还是'ts'类型


// **********
// never后的代码会变成Deadcode不再会执行
// **********
function bar() {
  foo(); // 这里的foo返回never
  console.log('Unreachable code'); // Errror: 编译器报错，此行代码永远不会执行到
}
                       
let foo: never;
let bar: any = {};
foo = bar; // Error: 不能把非never类型赋值给never类型，包括any
```

### 字符串模板

```typescript
// **********
// 基础用法
// **********
type World = "world";
type Greeting = `hello ${World}`;
// type Greeting = "hello world";

// **********
// 联合类型
// **********
type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
// type AllLocaleIDs = "welcome_email_id" | "email_heading_id" | "footer_title_id" | "footer_sendoff_id";


// **********
// 通过字符串拼接，限制foo.on的eventName参数值为firstNameChanged|lastNameChanged|ageChanged
// **********
type Listenable<T> = {
  on(
    eventName: `${string & keyof T}Changed`,
    callback: (newValue: any) => void,
  ): void;
}
declare function watch<T>(obj: T): T & Listenable<T>;
const foo = watch({
  firstName: "wilson",
  lastName: "zeng",
  age: 20,
});
foo.on("firstNameChanged", () => {
  console.log('firstNameChanged was changed');
});

```

## 高级概念

### 函数重载

```typescript
// *******
// 基本定义
// *******
function foo(a: string): number; // 重载定义1
function foo(a: string, b: number): number; // 重载定义2

function foo(a: string, b?: number): number {
  // 具体实现
}

foo('bar'); // 应用重载规则1
foo('bar', 1); // 应用重载规则2


// **********
// 实际场景举例
// **********
interface User {
 name: string;
  age: number;
}

// 第一个参数可以传入用户或用户ID，但是当传入用户ID时，必须传入一个idChecker方法，强依赖，这时就需要通过函数重载来实现
function saveUser(userOrId: User | number, idChecker?: () => boolean): void {
  // ...
}

// 实现方式
function saveUser(user: User): User;
function saveUser(id: number, idChecker: () => boolean): number;
function saveUser(userOrId: User | number, idChecker?: () => boolean): User | number {
  // ...
}

saveUser({ name: '用户名', age: 20 }); // 通过：传入User
saveUser(30, () => true); // 通过：传入ID
saveUser(30); // Error: Argument of type 'number' is not assignable to parameter of type 'User'
```

### 接口

```typescript
// ******
// 接口基本定义
// ******
// 接口
interface Point {
  x: number;
  y: number;
}
declare const myPoint: Point;

// 内联注解
declare const myPoint: { x: number; y: number };


// ******
// 描述函数结构
// *****
interface AddFunc {
 (a: number, b: number): number; 
}

const sum: AddFunc = function (a: number, b: number) {
  // ...
};

// ***********
// 描述类的实现
// ***********
interface BaseUser {
 name: string; 
}

class User implements BaseUser {
  // Error: Property 'name' is missing
  title: string = '';
  
  constructor() {
    return { title: 'hello' };
  }
}

// ************
// 描述构造函数
// ***********
// 通过new关键字描述构造函数
function createUser(ctor: { new(): { title: string } }) {
  return new ctor();
}

const user = createUser(User); // 返回对象: { title: 'hello' }

// *********
// 接口的开放性
// *********
// 不允许重名，但是在不同文件可以重复声明
// Lib a.d.ts
interface Point {
  x: number;
  y: number;
}
declare const myPoint: Point;

// Lib b.d.ts
interface Point {
  z: number;
}

// Your code
myPoint.z // Allowed!

// *********
// 接口继承
// ********
// 通过extends继承
interface MyPoint extends Point {
  name: string;
}

// *********
// 接口与类
// *********
// TS的类既可以作为类使用，也可以作为接口使用
class Point {
  x: number;
  y: number;
}
const p0 = new Point(); // 实例化Point
declare const p: Point; // 声明p为Point类型

// ********
// 接口继承类
// ********
class Point {
  x: number;
  y: number;
  constructor(x: number, y: number) {
    // ....
  }
}
// 之所以接口可以继承类，是因为TS的类会同时声明一个接口，因此实际上是接口继承接口
interface Point3D extends Point {
  z: number;
}


// ***********
// 接口与type
// ***********
interface Foo { name: string; } // 接口 - 接口是描述结构的类型
type Foo = { name: string; } // type - type是类型的别名
interface Foo { name: string; } === { name: string; } // 接口等同接口的字面量形式

interface Foo<T> { name: T; } // 接口 - 接口是描述结构的类型
type Foo<T> = { name: T; } // type - type是类型的别名
interface Foo<T>{ name: T; } === { name: T; } // 接口等同接口的字面量形式
```

### 泛型

